{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Angular localization An Angular library to translate messages, dates and numbers This library is for localization of Angular v7 apps. It allows, in addition to translation, to localize numbers and dates of your app, adding language code , country code , currency code , timezone and optionally script code , numbering system and calendar , through Internationalization API . It also implements the validation of numbers by locales. Sample app built with Angular CLI Material, and its source code . Library version: 7.0.2 - Changelog Installing You can add angular-l10n to your project using npm : npm install angular-l10n --save","title":"Home"},{"location":"#angular-localization","text":"An Angular library to translate messages, dates and numbers This library is for localization of Angular v7 apps. It allows, in addition to translation, to localize numbers and dates of your app, adding language code , country code , currency code , timezone and optionally script code , numbering system and calendar , through Internationalization API . It also implements the validation of numbers by locales. Sample app built with Angular CLI Material, and its source code . Library version: 7.0.2 - Changelog","title":"Angular localization"},{"location":"#installing","text":"You can add angular-l10n to your project using npm : npm install angular-l10n --save","title":"Installing"},{"location":"quick-start/","text":"Quick start First scenario: you only need to translate texts Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` h1 {{ title }} /h1 h3 {{ 'changeLanguage' | translate:lang }} /h3 button (click)= selectLanguage('en'); English /button button (click)= selectLanguage('it'); Italiano /button app-home /app-home ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } selectLanguage(language: string): void { this.locale.setCurrentLanguage(language); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` p {{ 'greeting' | translate:lang }} /p p title= {{ 'greeting' | translate:lang }} {{ 'subtitle' | translate:lang }} /p ` }) export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { title : Angular localization , subtitle : It's a small world , changeLanguage : Change language , greeting : Hi! } { title : Localizzazione in Angular , subtitle : Il mondo \u00e8 piccolo , changeLanguage : Cambia lingua , greeting : Ciao! } Using directives In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component } from '@angular/core'; @Component({ selector: 'app-home', template: ` p l10nTranslate greeting /p p l10n-title title= greeting l10nTranslate subtitle /p ` }) export class HomeComponent { } Note that if you use in the component only the directives and not the pipes , you don't need to use @Language() decorator . Second scenario: you need to translate texts, dates numbers Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, LocalizationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` h1 {{ title }} /h1 h3 {{ 'changeCountry' | translate:lang }} /h3 button (click)= selectLocale('en', 'US', 'USD'); United States /button button (click)= selectLocale('en', 'GB', 'GBP'); United Kingdom /button button (click)= selectLocale('it', 'IT', 'EUR'); Italia /button app-home /app-home ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } selectLocale(language: string, country: string, currency: string): void { this.locale.setDefaultLocale(language, country); this.locale.setCurrentCurrency(currency); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language, DefaultLocale, Currency } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` p {{ 'greeting' | translate:lang }} /p p title= {{ 'greeting' | translate:lang }} {{ 'subtitle' | translate:lang }} /p p {{ today | l10nDate:defaultLocale:'fullDate' }} /p p {{ pi | l10nDecimal:defaultLocale:'1.5-5' }} /p p {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }} /p button (click)= change() {{ 'change' | translate:lang }} /button ` }) export class HomeComponent implements OnInit { @Language() lang: string; @DefaultLocale() defaultLocale: string; @Currency() currency: string; today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { title : Angular localization , subtitle : It's a small world , changeCountry : Change country , greeting : Hi! , change : Change } { title : Localizzazione in Angular , subtitle : Il mondo \u00e8 piccolo , changeCountry : Cambia Paese , greeting : Ciao! , change : Cambia } Finally, to extend the support to old browsers, add the following script tag in index.html : script src= https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US,Intl.~locale.en-GB,Intl.~locale.it-IT /script Using directives In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-home', template: ` p l10nTranslate greeting /p p l10n-title title= greeting l10nTranslate subtitle /p p format= fullDate l10nDate {{ today }} /p p digits= 1.5-5 l10nDecimal {{ pi }} /p p digits= 1.2-2 currencyDisplay= symbol l10nCurrency {{ value }} /p button (click)= change() l10nTranslate change /button ` }) export class HomeComponent implements OnInit { today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } Note that if you use in the component only the directives and not the pipes , you don't need to use decorators . Advanced initialization If you want the app to be rendered only after the translation file is loaded, you can use these settings in app.module.ts : import { NgModule, APP_INITIALIZER } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; // Advanced initialization. export function initL10n(l10nLoader: L10nLoader): Function { return () = l10nLoader.load(); } // APP_INITIALIZER will execute the function when the app is initialized and delay what it provides. @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], providers: [ { provide: APP_INITIALIZER, useFactory: initL10n, deps: [L10nLoader], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Appendix A - Using Angular CLI If you are using Angular CLI , you have to add the json files in src/assets folder, copied as-is when building your project. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix B - Using Ionic You have to add the json files in www/assets folder. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix C - Using Angular Meteor You must create public/assets folder at the root of your app. In this way, assets folder is copied directly into your application bundle. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ... Appendix D - Using Angular Universal There are two ways: Prerender (prerender) Happens at build time. Renders your application and replaces the dist index.html with a version rendered at the route / . Server-Side Rendering (ssr) Happens at runtime. Uses a server Engine to render you application on the fly at the requested url. Note This library builds only one app, and not an app for each language as Angular i18n native solution: so your prerendered index.html will contain the translation according to the language defined during the configuration. If you use Direct loading , there are no particular warnings. If you use Asynchronous loading , you have to solve the problem of http requests during prerender or ssr : About prerender : you need to provide absolute URLs to a running server that will be the same that will serve the data (or through a proxy): if this is not possible and you want to use the prerender instead of ssr , you should use Angular i18n native solution. About ssr : you only need to use absolute URLs , so for example: ... providers: [ { type: ProviderType.Static, prefix: 'http:localhost:4000/assets/locale-' } ], ... Please note that problems with http requests are not due to this library, but to common questions about http requests in Universal apps. The following is an example that uses Asynchronous loading , based on Angular Universal Starter : app.module.ts : const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [], caching: true } }; @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef, @Inject(PLATFORM_ID) private platformId: Object ) { } load(): Promise any { if (isPlatformBrowser(this.platformId)) { // Client only code. this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; } if (isPlatformServer(this.platformId)) { // Server only code. this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: 'http://localhost:4000/assets/locale-' } ]; } return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () = localizationConfig.load(); } @NgModule({ ... imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], providers: [ LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Now, depending on whether you want to use the prerender or ssr in production, you must proceed as follows: prerender npm run build:ssr npm run serve:ssr The server is ready, so you can generate the pre-built files. Open a new terminal and type: npm run generate:prerender If you see in the dist/browser folder, your html files should have the translated values (in the default language). To test it: npm run serve:prerender ssr npm run build:ssr npm run serve:ssr","title":"Quick start"},{"location":"quick-start/#quick-start","text":"","title":"Quick start"},{"location":"quick-start/#first-scenario-you-only-need-to-translate-texts","text":"Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` h1 {{ title }} /h1 h3 {{ 'changeLanguage' | translate:lang }} /h3 button (click)= selectLanguage('en'); English /button button (click)= selectLanguage('it'); Italiano /button app-home /app-home ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } selectLanguage(language: string): void { this.locale.setCurrentLanguage(language); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` p {{ 'greeting' | translate:lang }} /p p title= {{ 'greeting' | translate:lang }} {{ 'subtitle' | translate:lang }} /p ` }) export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { title : Angular localization , subtitle : It's a small world , changeLanguage : Change language , greeting : Hi! } { title : Localizzazione in Angular , subtitle : Il mondo \u00e8 piccolo , changeLanguage : Cambia lingua , greeting : Ciao! }","title":"First scenario: you only need to translate texts"},{"location":"quick-start/#using-directives","text":"In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component } from '@angular/core'; @Component({ selector: 'app-home', template: ` p l10nTranslate greeting /p p l10n-title title= greeting l10nTranslate subtitle /p ` }) export class HomeComponent { } Note that if you use in the component only the directives and not the pipes , you don't need to use @Language() decorator .","title":"Using directives"},{"location":"quick-start/#second-scenario-you-need-to-translate-texts-dates-numbers","text":"Install the library: npm install angular-l10n --save Import the modules you need and configure the library in app.module.ts : import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, LocalizationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(public l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Add to app.component.ts : import { Component, OnInit } from '@angular/core'; import { LocaleService, TranslationService, Language } from 'angular-l10n'; @Component({ selector: 'app-root', template: ` h1 {{ title }} /h1 h3 {{ 'changeCountry' | translate:lang }} /h3 button (click)= selectLocale('en', 'US', 'USD'); United States /button button (click)= selectLocale('en', 'GB', 'GBP'); United Kingdom /button button (click)= selectLocale('it', 'IT', 'EUR'); Italia /button app-home /app-home ` }) export class AppComponent implements OnInit { @Language() lang: string; title: string; constructor(public locale: LocaleService, public translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } selectLocale(language: string, country: string, currency: string): void { this.locale.setDefaultLocale(language, country); this.locale.setCurrentCurrency(currency); } } Add home.component.ts : import { Component, OnInit } from '@angular/core'; import { Language, DefaultLocale, Currency } from 'angular-l10n'; @Component({ selector: 'app-home', template: ` p {{ 'greeting' | translate:lang }} /p p title= {{ 'greeting' | translate:lang }} {{ 'subtitle' | translate:lang }} /p p {{ today | l10nDate:defaultLocale:'fullDate' }} /p p {{ pi | l10nDecimal:defaultLocale:'1.5-5' }} /p p {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }} /p button (click)= change() {{ 'change' | translate:lang }} /button ` }) export class HomeComponent implements OnInit { @Language() lang: string; @DefaultLocale() defaultLocale: string; @Currency() currency: string; today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Create the json files of the translations such as locale-en.json and locale-it.json in src/assets folder: { title : Angular localization , subtitle : It's a small world , changeCountry : Change country , greeting : Hi! , change : Change } { title : Localizzazione in Angular , subtitle : Il mondo \u00e8 piccolo , changeCountry : Cambia Paese , greeting : Ciao! , change : Cambia } Finally, to extend the support to old browsers, add the following script tag in index.html : script src= https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US,Intl.~locale.en-GB,Intl.~locale.it-IT /script","title":"Second scenario: you need to translate texts, dates &amp; numbers"},{"location":"quick-start/#using-directives_1","text":"In addition to the pipes , you can use directives . Try to change home.component.ts : import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-home', template: ` p l10nTranslate greeting /p p l10n-title title= greeting l10nTranslate subtitle /p p format= fullDate l10nDate {{ today }} /p p digits= 1.5-5 l10nDecimal {{ pi }} /p p digits= 1.2-2 currencyDisplay= symbol l10nCurrency {{ value }} /p button (click)= change() l10nTranslate change /button ` }) export class HomeComponent implements OnInit { today: number; pi: number; value: number; ngOnInit(): void { this.today = Date.now(); this.pi = 3.14159; this.value = Math.round(Math.random() * 1000000) / 100; } change(): void { this.value = Math.round(Math.random() * 1000000) / 100; } } Note that if you use in the component only the directives and not the pipes , you don't need to use decorators .","title":"Using directives"},{"location":"quick-start/#advanced-initialization","text":"If you want the app to be rendered only after the translation file is loaded, you can use these settings in app.module.ts : import { NgModule, APP_INITIALIZER } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { HomeComponent } from './home/home.component'; import { L10nConfig, L10nLoader, TranslationModule, StorageStrategy, ProviderType, LogLevel } from 'angular-l10n'; const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; // Advanced initialization. export function initL10n(l10nLoader: L10nLoader): Function { return () = l10nLoader.load(); } // APP_INITIALIZER will execute the function when the app is initialized and delay what it provides. @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], providers: [ { provide: APP_INITIALIZER, useFactory: initL10n, deps: [L10nLoader], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { }","title":"Advanced initialization"},{"location":"quick-start/#appendix-a-using-angular-cli","text":"If you are using Angular CLI , you have to add the json files in src/assets folder, copied as-is when building your project. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix A - Using Angular CLI"},{"location":"quick-start/#appendix-b-using-ionic","text":"You have to add the json files in www/assets folder. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix B - Using Ionic"},{"location":"quick-start/#appendix-c-using-angular-meteor","text":"You must create public/assets folder at the root of your app. In this way, assets folder is copied directly into your application bundle. Always configure your provider in this way: ... providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], ...","title":"Appendix C - Using Angular Meteor"},{"location":"quick-start/#appendix-d-using-angular-universal","text":"There are two ways:","title":"Appendix D - Using Angular Universal"},{"location":"quick-start/#prerender-prerender","text":"Happens at build time. Renders your application and replaces the dist index.html with a version rendered at the route / .","title":"Prerender (prerender)"},{"location":"quick-start/#server-side-rendering-ssr","text":"Happens at runtime. Uses a server Engine to render you application on the fly at the requested url. Note This library builds only one app, and not an app for each language as Angular i18n native solution: so your prerendered index.html will contain the translation according to the language defined during the configuration. If you use Direct loading , there are no particular warnings. If you use Asynchronous loading , you have to solve the problem of http requests during prerender or ssr : About prerender : you need to provide absolute URLs to a running server that will be the same that will serve the data (or through a proxy): if this is not possible and you want to use the prerender instead of ssr , you should use Angular i18n native solution. About ssr : you only need to use absolute URLs , so for example: ... providers: [ { type: ProviderType.Static, prefix: 'http:localhost:4000/assets/locale-' } ], ... Please note that problems with http requests are not due to this library, but to common questions about http requests in Universal apps. The following is an example that uses Asynchronous loading , based on Angular Universal Starter : app.module.ts : const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [], caching: true } }; @Injectable() export class LocalizationConfig { constructor( public l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef, @Inject(PLATFORM_ID) private platformId: Object ) { } load(): Promise any { if (isPlatformBrowser(this.platformId)) { // Client only code. this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; } if (isPlatformServer(this.platformId)) { // Server only code. this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: 'http://localhost:4000/assets/locale-' } ]; } return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () = localizationConfig.load(); } @NgModule({ ... imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], providers: [ LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], bootstrap: [AppComponent] }) export class AppModule { } Now, depending on whether you want to use the prerender or ssr in production, you must proceed as follows: prerender npm run build:ssr npm run serve:ssr The server is ready, so you can generate the pre-built files. Open a new terminal and type: npm run generate:prerender If you see in the dist/browser folder, your html files should have the translated values (in the default language). To test it: npm run serve:prerender ssr npm run build:ssr npm run serve:ssr","title":"Server-Side Rendering (ssr)"},{"location":"spec/api/","text":"Services APIs TranslationModule Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders TranslationModule Use in AppModule : new instances of LocaleService TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders TranslationModule Use in feature modules with lazy loading: new instance of TranslationService LocalizationModule Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders LocalizationModule Use in AppModule : new instances of LocaleService TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders LocalizationModule Use in feature modules with lazy loading: new instance of TranslationService LocaleValidationModule Method Function static forRoot(): ModuleWithProviders LocaleValidationModule Use in AppModule : new instance of LocaleValidation LocaleSeoModule Method Function static forRoot(): ModuleWithProviders LocaleSeoModule Use in AppModule : new instance of SearchService static forChild(): ModuleWithProviders LocaleSeoModule Use in feature modules with lazy loading: new instance of SearchService L10nLoader Method Function abstract load(): Promise any Loads l10n services ILocaleService Property Value languageCodeChanged: Subject string Fired when the language changes. Returns the language code defaultLocaleChanged: Subject string Fired when the default locale changes. Returns the default locale currencyCodeChanged: Subject string Fired when the currency changes. Returns the currency code timezoneChanged: Subject string Fired when the timezone changes. Returns the timezone Method Function getConfiguration(): L10nConfigRef['locale'] init(): Promise void getBrowserLanguage(): string | null getAvailableLanguages(): string[] getLanguageDirection(languageCode?: string): string getCurrentLanguage(): string getCurrentCountry(): string getCurrentScript(): string getCurrentLocale(): string Returns the well formatted locale as {languageCode}[-scriptCode][-countryCode] getCurrentNumberingSystem(): string getCurrentCalendar(): string getDefaultLocale(): string getCurrentCurrency(): string getCurrencySymbol(currencyDisplay?: string, defaultLocale?: string, currency?: string): string getCurrentTimezone(): string setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void formatDate(value: any, format?: string | DateTimeOptions, defaultLocale?: string, timezone?: string): string Formats a date according to default locale formatDecimal(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string Formats a decimal number according to default locale formatPercent(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string Formats a number as a percentage according to default locale formatCurrency(value: any, digits?: string | DigitsOptions, currencyDisplay?: string, defaultLocale?: string, currency?: string): string Formats a number as a currency according to default locale composeLocale(codes: ISOCode[]): string rollback(): void Rollbacks to previous language, default locale, currency timezone ITranslationService Property Value translationError: Subject any Fired when the translation data could not been loaded. Returns the error Method Function getConfiguration(): L10nConfigRef['translation'] init(): Promise any translationChanged(): Observable string Fired when the translation data has been loaded. Returns the translation language latestTranslation(): Observable string Fired when the latest translationChanged is emitted. Returns the translation language. Used when the reference to the service is not known, as in decorators translate(keys: string | string[], args?: any, lang?: string): string | any Translates a key or an array of keys translateAsync(keys: string | string[], args?: any, lang?: string): Observable string | any ILocaleValidation Method Function parseNumber(s: string, digits?: string, defaultLocale?: string): number | null Converts a string to a number according to default locale. If the string cannot be converted to a number, returns NaN ISearchService Method Function updateHead(page: string): void Translates the title of the page and the provided meta tags ICollator Method Function compare(key1: string, key2: string, extension?: string, options?: any): number Compares two keys by the value of translation according to the current language sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] Sorts an array of objects or an array of arrays according to the current language sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable any[] Sorts asynchronously an array of objects or an array of arrays according to the current language search(s: string, list: any[], keyNames: any[], options?: any): any[] Matches a string into an array of objects or an array of arrays according to the current language searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable any[] Matches asynchronously a string into an array of objects or an array of arrays according to the current language IntlAPI Method Function static hasIntl(): boolean static hasDateTimeFormat(): boolean static hasTimezone(): boolean static hasNumberFormat(): boolean static hasCollator(): boolean LocaleStorage Method Function abstract read(name: string): Promise string | null This method must contain the logic to read the storage abstract write(name: string, value: string): Promise void This method must contain the logic to write the storage TranslationProvider Method Function abstract getTranslation(language: string, args: any): Observable any This method must contain the logic of data access TranslationHandler Method Function abstract parseValue(path: string, key: string, value: string | null, args: any, lang: string): string This method must contain the logic to parse the translated value Translation Property Value lang: string Localization Property Value lang: string defaultLocale: string currency: string timezone: string","title":"Services APIs"},{"location":"spec/api/#services-apis","text":"","title":"Services APIs"},{"location":"spec/api/#translationmodule","text":"Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders TranslationModule Use in AppModule : new instances of LocaleService TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders TranslationModule Use in feature modules with lazy loading: new instance of TranslationService","title":"TranslationModule"},{"location":"spec/api/#localizationmodule","text":"Method Function static forRoot(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders LocalizationModule Use in AppModule : new instances of LocaleService TranslationService static forChild(l10nConfig: L10nConfig, token?: Token): ModuleWithProviders LocalizationModule Use in feature modules with lazy loading: new instance of TranslationService","title":"LocalizationModule"},{"location":"spec/api/#localevalidationmodule","text":"Method Function static forRoot(): ModuleWithProviders LocaleValidationModule Use in AppModule : new instance of LocaleValidation","title":"LocaleValidationModule"},{"location":"spec/api/#localeseomodule","text":"Method Function static forRoot(): ModuleWithProviders LocaleSeoModule Use in AppModule : new instance of SearchService static forChild(): ModuleWithProviders LocaleSeoModule Use in feature modules with lazy loading: new instance of SearchService","title":"LocaleSeoModule"},{"location":"spec/api/#l10nloader","text":"Method Function abstract load(): Promise any Loads l10n services","title":"L10nLoader"},{"location":"spec/api/#ilocaleservice","text":"Property Value languageCodeChanged: Subject string Fired when the language changes. Returns the language code defaultLocaleChanged: Subject string Fired when the default locale changes. Returns the default locale currencyCodeChanged: Subject string Fired when the currency changes. Returns the currency code timezoneChanged: Subject string Fired when the timezone changes. Returns the timezone Method Function getConfiguration(): L10nConfigRef['locale'] init(): Promise void getBrowserLanguage(): string | null getAvailableLanguages(): string[] getLanguageDirection(languageCode?: string): string getCurrentLanguage(): string getCurrentCountry(): string getCurrentScript(): string getCurrentLocale(): string Returns the well formatted locale as {languageCode}[-scriptCode][-countryCode] getCurrentNumberingSystem(): string getCurrentCalendar(): string getDefaultLocale(): string getCurrentCurrency(): string getCurrencySymbol(currencyDisplay?: string, defaultLocale?: string, currency?: string): string getCurrentTimezone(): string setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void formatDate(value: any, format?: string | DateTimeOptions, defaultLocale?: string, timezone?: string): string Formats a date according to default locale formatDecimal(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string Formats a decimal number according to default locale formatPercent(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string Formats a number as a percentage according to default locale formatCurrency(value: any, digits?: string | DigitsOptions, currencyDisplay?: string, defaultLocale?: string, currency?: string): string Formats a number as a currency according to default locale composeLocale(codes: ISOCode[]): string rollback(): void Rollbacks to previous language, default locale, currency timezone","title":"ILocaleService"},{"location":"spec/api/#itranslationservice","text":"Property Value translationError: Subject any Fired when the translation data could not been loaded. Returns the error Method Function getConfiguration(): L10nConfigRef['translation'] init(): Promise any translationChanged(): Observable string Fired when the translation data has been loaded. Returns the translation language latestTranslation(): Observable string Fired when the latest translationChanged is emitted. Returns the translation language. Used when the reference to the service is not known, as in decorators translate(keys: string | string[], args?: any, lang?: string): string | any Translates a key or an array of keys translateAsync(keys: string | string[], args?: any, lang?: string): Observable string | any","title":"ITranslationService"},{"location":"spec/api/#ilocalevalidation","text":"Method Function parseNumber(s: string, digits?: string, defaultLocale?: string): number | null Converts a string to a number according to default locale. If the string cannot be converted to a number, returns NaN","title":"ILocaleValidation"},{"location":"spec/api/#isearchservice","text":"Method Function updateHead(page: string): void Translates the title of the page and the provided meta tags","title":"ISearchService"},{"location":"spec/api/#icollator","text":"Method Function compare(key1: string, key2: string, extension?: string, options?: any): number Compares two keys by the value of translation according to the current language sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] Sorts an array of objects or an array of arrays according to the current language sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable any[] Sorts asynchronously an array of objects or an array of arrays according to the current language search(s: string, list: any[], keyNames: any[], options?: any): any[] Matches a string into an array of objects or an array of arrays according to the current language searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable any[] Matches asynchronously a string into an array of objects or an array of arrays according to the current language","title":"ICollator"},{"location":"spec/api/#intlapi","text":"Method Function static hasIntl(): boolean static hasDateTimeFormat(): boolean static hasTimezone(): boolean static hasNumberFormat(): boolean static hasCollator(): boolean","title":"IntlAPI"},{"location":"spec/api/#localestorage","text":"Method Function abstract read(name: string): Promise string | null This method must contain the logic to read the storage abstract write(name: string, value: string): Promise void This method must contain the logic to write the storage","title":"LocaleStorage"},{"location":"spec/api/#translationprovider","text":"Method Function abstract getTranslation(language: string, args: any): Observable any This method must contain the logic of data access","title":"TranslationProvider"},{"location":"spec/api/#translationhandler","text":"Method Function abstract parseValue(path: string, key: string, value: string | null, args: any, lang: string): string This method must contain the logic to parse the translated value","title":"TranslationHandler"},{"location":"spec/api/#translation","text":"Property Value lang: string","title":"Translation"},{"location":"spec/api/#localization","text":"Property Value lang: string defaultLocale: string currency: string timezone: string","title":"Localization"},{"location":"spec/collator/","text":"Collator Import the module: @NgModule({ imports: [ ... CollatorModule // New instance of Collator. ], declarations: [ListComponent] }) export class ListModule { } Collator class has the following methods for sorting and filtering a list by locales: sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable any[] search(s: string, list: any[], keyNames: any[], options?: any): any[] searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable any[] These methods use the Intl.Collator object, a constructor for collators, objects that enable language sensitive string comparison.","title":"Collator"},{"location":"spec/collator/#collator","text":"Import the module: @NgModule({ imports: [ ... CollatorModule // New instance of Collator. ], declarations: [ListComponent] }) export class ListModule { } Collator class has the following methods for sorting and filtering a list by locales: sort(list: any[], keyName: any, order?: string, extension?: string, options?: any): any[] sortAsync(list: any[], keyName: any, order?: string, extension?: string, options?: any): Observable any[] search(s: string, list: any[], keyNames: any[], options?: any): any[] searchAsync(s: string, list: any[], keyNames: any[], options?: any): Observable any[] These methods use the Intl.Collator object, a constructor for collators, objects that enable language sensitive string comparison.","title":"Collator"},{"location":"spec/configuration/","text":"Configuration Loading Angular CLI No need to set up anything, just import it in your code. Rollup or webpack No need to set up anything, just import it in your code. Using SystemJS configuration System.config({ map: { 'angular-l10n': 'node_modules/angular-l10n/bundles/angular-l10n.umd.js' } }); Plain JavaScript If you build apps in Angular using ES5, you can include the umd bundle in your index.html : script src= node_modules/angular-l10n/bundles/angular-l10n.umd.js /script and use global ng.l10n namespace. First scenario: you only need to translate messages Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Second scenario: you need to translate messages, dates numbers Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } } Configuration settings The L10nConfig interface contains the properties to configure the library. L10nConfig Property Nested property Value locale? Locale service configuration languages?: Language[] Adds the languages to use in the app language?: string Defines the language ISO 639 two-letter or three-letter code to be used, if the language is not found in the browser defaultLocale?: DefaultLocale Defines the default locale to be used, regardless of the browser language currency?: string Defines the currency ISO 4217 three-letter code to be used timezone?: string The time zone name of the IANA time zone database to use storage?: StorageStrategy Defines the storage to be used for default locale, currency timezone cookieExpiration?: number If the cookie expiration is omitted, the cookie becomes a session cookie translation? Translation service configuration translationData?: Array { languageCode: string; data: any; } Direct loading: adds translation data providers?: any[] Asynchronous loading: adds translation providers caching?: Boolean Asynchronous loading: disables/enables the cache for translation providers version?: string Asynchronous loading: adds the query parameter ver to the http requests timeout?: number Asynchronous loading: sets a timeout in milliseconds for the http requests rollbackOnError?: boolean Asynchronous loading: rollbacks to previous default locale, currency and timezone on error composedLanguage?: ISOCode[] Sets a composed language for translations missingValue?: string | ((path: string) = string) Sets the value or the function to use for missing keys missingKey?: string Sets the key to use for missing keys composedKeySeparator?: string Sets composed key separator i18nPlural?: boolean Disables/enables the translation of numbers that are contained at the beginning of the keys logger? Logger configuration level?: LogLevel Defines the log level localizedRouting? Localized routing configuration format?: ISOCode[] Defines the format of the localized routing defaultRouting?: boolean Disables/enables default routing for default language or locale schema?: Schema[] Provides the schema to the default behaviour of localized routing search? Search configuration metaTags?: string[] List of meta tag names to translate localeInterceptor? Locale interceptor configuration format?: ISOCode[] Defines the format of the Accept-Language header There aren't default values: you must explicitly set each parameter you need. Configuration token The configuration settings are stored in the following InjectionToken : Token Interface L10N_CONFIG L10nConfigRef Dynamic settings If you need to load the configuration data dynamically, you can provide a partial or empty L10nConfig in AppModule , and then update the token in your class: const l10nConfig: L10nConfig = { ... translation: { providers: [], // Not available here. caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], ... }) export class AppModule { constructor( private l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef ) { this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; this.l10nLoader.load(); } } Configuration must be completed before invoking the load method of L10nLoader . Or whether you use the advanced initialization : @Injectable() export class LocalizationConfig { constructor( private l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef ) { } load(): Promise any { this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () = localizationConfig.load(); } @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], providers: [ ... LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], ... }) export class AppModule { } Logger For development, you can enable the logger: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, ... }; In this way, you will be warned of the most common errors in the implementation of this library, such as missing functions or invalid formats. To turn off it in production, you can use: const l10nConfig: L10nConfig = { logger: { level: environment.production ? LogLevel.Off : LogLevel.Warn }, ... }; Loading the translation data Direct loading You can use translationData setting when you configure the service, adding all the translation data: const translationEN: any = { Title: Angular localization }; const translationIT: any = { Title: Localizzazione in Angular }; const l10nConfig: L10nConfig = { ... translation: { translationData: [ { languageCode: 'en', data: translationEN }, { languageCode: 'it', data: translationIT } ] } }; Asynchronous loading of JSON files You can add all the providers you need: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ] } }; You can use Direct and Asynchronous loading at the same time. Translation data of Direct loading will be merged before the data of Asynchronous loading. Asynchronous loading through a Web API You can also load the data through a Web API: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.WebAPI, path: 'http://localhost:54703/api/values/' } ] } }; ... export class AppModule { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) = { if (error) { console.log(error); } }); } } [path]{languageCode} will be the URL used by the Http GET requests. So the example URI will be something like: http://localhost:54703/api/values/en . Using fallback providers if you need a cascade fallback when the key is not found, you can use fallback providers: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Fallback, prefix: './assets/global', fallbackLanguage: [] }, { type: ProviderType.Fallback, prefix: './assets/locale-', fallbackLanguage: [ISOCode.Language] }, { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; and create the json files such as global.json , locale-en.json , locale-en-US.json . When you set a fallback provider, the translation data will be merged in order : if a key is found in the en-US file, it is used, otherwise the key in en file and finally the key in global file. Using a custom provider If you need, you can create a custom provider to load translation data. Implement TranslationProvider class-interface and the getTranslation method with the logic to retrieve the data: @Injectable() export class CustomTranslationProvider implements TranslationProvider { /** * This method must contain the logic of data access. * @param language The current language * @param args The object set during the configuration of 'providers' * @return An observable of an object of translation data: {key: value} */ public getTranslation(language: string, args: any): Observable any { ... return ... } } Note that the method must return an observable of an object . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationProvider: CustomTranslationProvider } ) ], ... }) See also TranslationProvider code. Caching You can enable the cache during configuration: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true } }; The next time a translation file will be required, will be taken from the cache without making a new http request , with a significant performance improvement: if the user returns to a language already selected; if you use a global file shared across lazy loaded modules. Error handling of data loading To find out if an error occurred during asynchronous loading of translation data, you have the translationError event: ... export class AppComponent { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) = { if (error) { console.log(error); } }); } } If the error occurs on the first loading of the application or a lazy loaded module, you can catch it with the load method: export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load() .catch(err = console.error(err)); } } If you use advanced initialization , you can catch it with the bootstrapModule method in main.ts . Rollback on errror If the error occurs when the user changes language, you can enable rollbackOnError option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... rollbackOnError: true } }; In this way, the application will keep the previous locatization without changing settings. Using a composed language By default, the languageCode is added as extension to the translation files. If you set composedLanguage during the configuration, the combination of supplied codes will be used as language: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' } }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; Your json files should be something like: ./assets/locale-en-US.json and so on. The available ISO codes are: language , country , script . Note that you have to configure defaultLocale and not only language . You must also use setDefaultLocale when the language changes. Default locale, currency timezone The default locale contains the current language and culture. It consists of: language code : ISO 639 two-letter or three-letter code of the language country code : ISO 3166 two-letter, uppercase code of the country and optionally: script code : used to indicate the script or writing system variations that distinguish the written forms of a language or its dialects. It consists of four letters and was defined according to the assignments found in ISO 15924 numbering system : possible values include: arab , arabext , bali , beng , deva , fullwide , gujr , guru , hanidec , khmr , knda , laoo , latn , limb , mlym , mong , mymr , orya , tamldec , telu , thai , tibt calendar : possible values include: buddhist , chinese , coptic , ethioaa , ethiopic , gregory , hebrew , indian , islamic , islamicc , iso8601 , japanese , persian , roc The currency contains the ISO 4217 currency codes. The timezone contains the time zone names of the IANA time zone database. For more information see Intl API . Storage The defaultLocale , the currency and the timezone chosen by the user are stored, and retrieved at the next access. During the configuration, you can choose your StorageStrategy : Session , Local , Cookie , Disabled . If you don't provide a different expiration using cookieExpiration , the cookie becomes a session cookie. You can also create a custom storage. Implement LocaleStorage class-interface and the read and write methods: @Injectable() export class CustomStorage implements LocaleStorage { /** * This method must contain the logic to read the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @return A promise with the value of the given name */ public async read(name: string): Promise string | null { ... return ... } /** * This method must contain the logic to write the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @param value The value for the given name */ public async write(name: string, value: string): Promise void { ... } } Note that the read method must return a promise . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { localeStorage: CustomStorage } ) ], ... }) See also LocaleStorage code. How the language is defined at the first loading Depending on the configuration, the library tries to define the language. If you set the language the library tries to get the language from the URL or tries to get the language from the storage or tries to get the language from the browser or uses the language set in the configuration If you set the default locale the library tries to get the defaultLocale from the URL or tries to get the defaultLocale from the storage or uses the defaultLocale set in the configuration That's because not all browsers return languageCode-countryCode . Intl API To localize dates and numbers , this library uses the Intl API . Check the current browser support: ECMAScript compatibility tables Can I use All modern browsers have implemented this API. You can use Intl.js to extend support to old browsers. Just add one script tag in your index.html : script src= https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US /script When specifying the features , you have to specify what locale, or locales to load. The timezone is also provided via Intl API . Except IE, all modern browsers have implemented the timezone. To extend the support, you can use Intl.DateTimeFormat timezone polyfill . When a feature is not supported, however, for example in older browsers, Angular localization does not generate an error in the browser, but returns the value without performing operations.","title":"Configuration"},{"location":"spec/configuration/#configuration","text":"","title":"Configuration"},{"location":"spec/configuration/#loading","text":"","title":"Loading"},{"location":"spec/configuration/#angular-cli","text":"No need to set up anything, just import it in your code.","title":"Angular CLI"},{"location":"spec/configuration/#rollup-or-webpack","text":"No need to set up anything, just import it in your code.","title":"Rollup or webpack"},{"location":"spec/configuration/#using-systemjs-configuration","text":"System.config({ map: { 'angular-l10n': 'node_modules/angular-l10n/bundles/angular-l10n.umd.js' } });","title":"Using SystemJS configuration"},{"location":"spec/configuration/#plain-javascript","text":"If you build apps in Angular using ES5, you can include the umd bundle in your index.html : script src= node_modules/angular-l10n/bundles/angular-l10n.umd.js /script and use global ng.l10n namespace.","title":"Plain JavaScript"},{"location":"spec/configuration/#first-scenario-you-only-need-to-translate-messages","text":"Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], language: 'en', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, TranslationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } }","title":"First scenario: you only need to translate messages"},{"location":"spec/configuration/#second-scenario-you-need-to-translate-messages-dates-numbers","text":"Import the modules you need and configure the library in the application root module: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, locale: { languages: [ { code: 'en', dir: 'ltr' }, { code: 'it', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Cookie }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ BrowserModule, HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [AppComponent, HomeComponent], bootstrap: [AppComponent] }) export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } }","title":"Second scenario: you need to translate messages, dates &amp; numbers"},{"location":"spec/configuration/#configuration-settings","text":"The L10nConfig interface contains the properties to configure the library.","title":"Configuration settings"},{"location":"spec/configuration/#l10nconfig","text":"Property Nested property Value locale? Locale service configuration languages?: Language[] Adds the languages to use in the app language?: string Defines the language ISO 639 two-letter or three-letter code to be used, if the language is not found in the browser defaultLocale?: DefaultLocale Defines the default locale to be used, regardless of the browser language currency?: string Defines the currency ISO 4217 three-letter code to be used timezone?: string The time zone name of the IANA time zone database to use storage?: StorageStrategy Defines the storage to be used for default locale, currency timezone cookieExpiration?: number If the cookie expiration is omitted, the cookie becomes a session cookie translation? Translation service configuration translationData?: Array { languageCode: string; data: any; } Direct loading: adds translation data providers?: any[] Asynchronous loading: adds translation providers caching?: Boolean Asynchronous loading: disables/enables the cache for translation providers version?: string Asynchronous loading: adds the query parameter ver to the http requests timeout?: number Asynchronous loading: sets a timeout in milliseconds for the http requests rollbackOnError?: boolean Asynchronous loading: rollbacks to previous default locale, currency and timezone on error composedLanguage?: ISOCode[] Sets a composed language for translations missingValue?: string | ((path: string) = string) Sets the value or the function to use for missing keys missingKey?: string Sets the key to use for missing keys composedKeySeparator?: string Sets composed key separator i18nPlural?: boolean Disables/enables the translation of numbers that are contained at the beginning of the keys logger? Logger configuration level?: LogLevel Defines the log level localizedRouting? Localized routing configuration format?: ISOCode[] Defines the format of the localized routing defaultRouting?: boolean Disables/enables default routing for default language or locale schema?: Schema[] Provides the schema to the default behaviour of localized routing search? Search configuration metaTags?: string[] List of meta tag names to translate localeInterceptor? Locale interceptor configuration format?: ISOCode[] Defines the format of the Accept-Language header There aren't default values: you must explicitly set each parameter you need.","title":"L10nConfig"},{"location":"spec/configuration/#configuration-token","text":"The configuration settings are stored in the following InjectionToken : Token Interface L10N_CONFIG L10nConfigRef","title":"Configuration token"},{"location":"spec/configuration/#dynamic-settings","text":"If you need to load the configuration data dynamically, you can provide a partial or empty L10nConfig in AppModule , and then update the token in your class: const l10nConfig: L10nConfig = { ... translation: { providers: [], // Not available here. caching: true, composedKeySeparator: '.', missingValue: 'No key' } }; @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], ... }) export class AppModule { constructor( private l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef ) { this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; this.l10nLoader.load(); } } Configuration must be completed before invoking the load method of L10nLoader . Or whether you use the advanced initialization : @Injectable() export class LocalizationConfig { constructor( private l10nLoader: L10nLoader, @Inject(L10N_CONFIG) private configuration: L10nConfigRef ) { } load(): Promise any { this.configuration.translation.providers = [ { type: ProviderType.Static, prefix: './assets/locale-' } ]; return this.l10nLoader.load(); } } export function initLocalization(localizationConfig: LocalizationConfig): Function { return () = localizationConfig.load(); } @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig) ], providers: [ ... LocalizationConfig, { provide: APP_INITIALIZER, useFactory: initLocalization, deps: [LocalizationConfig], multi: true } ], ... }) export class AppModule { }","title":"Dynamic settings"},{"location":"spec/configuration/#logger","text":"For development, you can enable the logger: const l10nConfig: L10nConfig = { logger: { level: LogLevel.Warn }, ... }; In this way, you will be warned of the most common errors in the implementation of this library, such as missing functions or invalid formats. To turn off it in production, you can use: const l10nConfig: L10nConfig = { logger: { level: environment.production ? LogLevel.Off : LogLevel.Warn }, ... };","title":"Logger"},{"location":"spec/configuration/#loading-the-translation-data","text":"","title":"Loading the translation data"},{"location":"spec/configuration/#direct-loading","text":"You can use translationData setting when you configure the service, adding all the translation data: const translationEN: any = { Title: Angular localization }; const translationIT: any = { Title: Localizzazione in Angular }; const l10nConfig: L10nConfig = { ... translation: { translationData: [ { languageCode: 'en', data: translationEN }, { languageCode: 'it', data: translationIT } ] } };","title":"Direct loading"},{"location":"spec/configuration/#asynchronous-loading-of-json-files","text":"You can add all the providers you need: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ] } }; You can use Direct and Asynchronous loading at the same time. Translation data of Direct loading will be merged before the data of Asynchronous loading.","title":"Asynchronous loading of JSON files"},{"location":"spec/configuration/#asynchronous-loading-through-a-web-api","text":"You can also load the data through a Web API: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.WebAPI, path: 'http://localhost:54703/api/values/' } ] } }; ... export class AppModule { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) = { if (error) { console.log(error); } }); } } [path]{languageCode} will be the URL used by the Http GET requests. So the example URI will be something like: http://localhost:54703/api/values/en .","title":"Asynchronous loading through a Web API"},{"location":"spec/configuration/#using-fallback-providers","text":"if you need a cascade fallback when the key is not found, you can use fallback providers: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Fallback, prefix: './assets/global', fallbackLanguage: [] }, { type: ProviderType.Fallback, prefix: './assets/locale-', fallbackLanguage: [ISOCode.Language] }, { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; and create the json files such as global.json , locale-en.json , locale-en-US.json . When you set a fallback provider, the translation data will be merged in order : if a key is found in the en-US file, it is used, otherwise the key in en file and finally the key in global file.","title":"Using fallback providers"},{"location":"spec/configuration/#using-a-custom-provider","text":"If you need, you can create a custom provider to load translation data. Implement TranslationProvider class-interface and the getTranslation method with the logic to retrieve the data: @Injectable() export class CustomTranslationProvider implements TranslationProvider { /** * This method must contain the logic of data access. * @param language The current language * @param args The object set during the configuration of 'providers' * @return An observable of an object of translation data: {key: value} */ public getTranslation(language: string, args: any): Observable any { ... return ... } } Note that the method must return an observable of an object . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationProvider: CustomTranslationProvider } ) ], ... }) See also TranslationProvider code.","title":"Using a custom provider"},{"location":"spec/configuration/#caching","text":"You can enable the cache during configuration: const l10nConfig: L10nConfig = { ... translation: { providers: [ { type: ProviderType.Static, prefix: './assets/global-' }, { type: ProviderType.Static, prefix: './assets/locale-' } ], caching: true } }; The next time a translation file will be required, will be taken from the cache without making a new http request , with a significant performance improvement: if the user returns to a language already selected; if you use a global file shared across lazy loaded modules.","title":"Caching"},{"location":"spec/configuration/#error-handling-of-data-loading","text":"To find out if an error occurred during asynchronous loading of translation data, you have the translationError event: ... export class AppComponent { constructor(private translation: TranslationService) { this.translation.translationError.subscribe((error) = { if (error) { console.log(error); } }); } } If the error occurs on the first loading of the application or a lazy loaded module, you can catch it with the load method: export class AppModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load() .catch(err = console.error(err)); } } If you use advanced initialization , you can catch it with the bootstrapModule method in main.ts .","title":"Error handling of data loading"},{"location":"spec/configuration/#rollback-on-errror","text":"If the error occurs when the user changes language, you can enable rollbackOnError option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... rollbackOnError: true } }; In this way, the application will keep the previous locatization without changing settings.","title":"Rollback on errror"},{"location":"spec/configuration/#using-a-composed-language","text":"By default, the languageCode is added as extension to the translation files. If you set composedLanguage during the configuration, the combination of supplied codes will be used as language: const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' } }, translation: { providers: [ { type: ProviderType.Static, prefix: './assets/locale-' } ], composedLanguage: [ISOCode.Language, ISOCode.Country] } }; Your json files should be something like: ./assets/locale-en-US.json and so on. The available ISO codes are: language , country , script . Note that you have to configure defaultLocale and not only language . You must also use setDefaultLocale when the language changes.","title":"Using a composed language"},{"location":"spec/configuration/#default-locale-currency-timezone","text":"The default locale contains the current language and culture. It consists of: language code : ISO 639 two-letter or three-letter code of the language country code : ISO 3166 two-letter, uppercase code of the country and optionally: script code : used to indicate the script or writing system variations that distinguish the written forms of a language or its dialects. It consists of four letters and was defined according to the assignments found in ISO 15924 numbering system : possible values include: arab , arabext , bali , beng , deva , fullwide , gujr , guru , hanidec , khmr , knda , laoo , latn , limb , mlym , mong , mymr , orya , tamldec , telu , thai , tibt calendar : possible values include: buddhist , chinese , coptic , ethioaa , ethiopic , gregory , hebrew , indian , islamic , islamicc , iso8601 , japanese , persian , roc The currency contains the ISO 4217 currency codes. The timezone contains the time zone names of the IANA time zone database. For more information see Intl API .","title":"Default locale, currency &amp; timezone"},{"location":"spec/configuration/#storage","text":"The defaultLocale , the currency and the timezone chosen by the user are stored, and retrieved at the next access. During the configuration, you can choose your StorageStrategy : Session , Local , Cookie , Disabled . If you don't provide a different expiration using cookieExpiration , the cookie becomes a session cookie. You can also create a custom storage. Implement LocaleStorage class-interface and the read and write methods: @Injectable() export class CustomStorage implements LocaleStorage { /** * This method must contain the logic to read the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @return A promise with the value of the given name */ public async read(name: string): Promise string | null { ... return ... } /** * This method must contain the logic to write the storage. * @param name 'defaultLocale', 'currency' or 'timezone' * @param value The value for the given name */ public async write(name: string, value: string): Promise void { ... } } Note that the read method must return a promise . Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { localeStorage: CustomStorage } ) ], ... }) See also LocaleStorage code.","title":"Storage"},{"location":"spec/configuration/#how-the-language-is-defined-at-the-first-loading","text":"Depending on the configuration, the library tries to define the language. If you set the language the library tries to get the language from the URL or tries to get the language from the storage or tries to get the language from the browser or uses the language set in the configuration If you set the default locale the library tries to get the defaultLocale from the URL or tries to get the defaultLocale from the storage or uses the defaultLocale set in the configuration That's because not all browsers return languageCode-countryCode .","title":"How the language is defined at the first loading"},{"location":"spec/configuration/#intl-api","text":"To localize dates and numbers , this library uses the Intl API . Check the current browser support: ECMAScript compatibility tables Can I use All modern browsers have implemented this API. You can use Intl.js to extend support to old browsers. Just add one script tag in your index.html : script src= https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en-US /script When specifying the features , you have to specify what locale, or locales to load. The timezone is also provided via Intl API . Except IE, all modern browsers have implemented the timezone. To extend the support, you can use Intl.DateTimeFormat timezone polyfill . When a feature is not supported, however, for example in older browsers, Angular localization does not generate an error in the browser, but returns the value without performing operations.","title":"Intl API"},{"location":"spec/getting-the-translation/","text":"Getting the translation To get the translation, this library uses pure pipes (to know the difference between pure and impure pipes see here ) or directives . You can also get the translation in component class. Pure pipes Pipe Type Format Pipe syntax Translate Message String expression | translate:lang L10nDate Date Date/Number/ISO string expression | l10nDate[:defaultLocale[:format[:timezone]]] L10nDecimal Decimal Number/string expression | l10nDecimal[:defaultLocale[:digits]] L10nPercent Percentage Number/string expression | l10nPercent[:defaultLocale[:digits]] L10nCurrency Currency Number/string expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digits]]]] You can dynamically change parameters and expressions values. Messages Implement Language decorator in the component to provide the parameter to translate pipe: export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. expression | translate:lang where expression is a string key that indicates the message to translate: {{ 'title' | translate:lang }} JSON : { title : Angular localization } Composed keys Set composedKeySeparator during the configuration, e.g. to '.' : {{ 'home.title' | translate:lang }} JSON : { home : { title : Angular localization } } Parameters {{ 'userNotifications' | translate:lang:{ user: username, NoMessages: messages.length } }} JSON : { userNotifications : {{ user }}, you have {{ NoMessages }} new messages } Dates Numbers Implement DefaultLocale , Currency optionally Timezone decorators in the component to provide defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent l10nCurrency pipes. export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Currency() currency: string; @Timezone() timezone: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. Dates expression | l10nDate[:defaultLocale[:format[:timezone]]] where: expression is a date object or a number (milliseconds since UTC epoch) or an ISO string. format indicates which date/time components to include. The format can be an alias as shown below: 'short' : equivalent to 'M/d/y, h:mm' (e.g. 8/29/2017, 4:37 PM for en-US ) 'medium' : equivalent to 'MMM d, y, h:mm:ss' (e.g. Aug 29, 2017, 4:32:43 PM for en-US ) 'long' : equivalent to 'MMMM d, y, h:mm:ss' (e.g. August 29, 2017, 4:32:43 PM for en-US ) 'shortDate' : equivalent to 'M/d/y' (e.g. 8/29/2017 for en-US ) 'mediumDate' : equivalent to 'MMM d, y' (e.g. Aug 29, 2017 for en-US ) 'longDate' : equivalent to 'MMMM d, y' (e.g. August 29, 2017 for en-US ) 'fullDate' : equivalent to 'EEEE, MMMM d, y' (e.g. Tuesday, August 29, 2017 for en-US ) 'shortTime' : equivalent to 'h:mm' (e.g. 4:53 PM for en-US ) 'mediumTime' : equivalent to 'h:mm:ss' (e.g. 4:54:15 PM for en-US ) It can also be a DateTimeOptions object with some or all of the following properties: weekday The representation of the weekday. Possible values are narrow , short , long . era The representation of the era. Possible values are narrow , short , long . year The representation of the year. Possible values are numeric , 2-digit . month The representation of the month. Possible values are numeric , 2-digit , narrow , short , long . day The representation of the day. Possible values are numeric , 2-digit . hour The representation of the hour. Possible values are numeric , 2-digit . minute The representation of the minute. Possible values are numeric , 2-digit . second The representation of the second. Possible values are numeric , 2-digit . timeZoneName The representation of the time zone name. Possible values are short , long . hour12 Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent. See Intl.DateTimeFormat for further information. Using format aliases {{ today | l10nDate:defaultLocale:'fullDate' }} Using a custom format @Component({ template: ` p {{ today | l10nDate:defaultLocale:options }} /p ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; today: Date = new Date(); options: DateTimeOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; ngOnInit(): void { } } Using timezone @Component({ template: ` p {{ today | l10nDate:defaultLocale:'medium':timezone }} /p ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Timezone() timezone: string; today: Date = new Date(); ngOnInit(): void { } } Decimals expression | l10nDecimal[:defaultLocale:[digits]] where: expression is a number or a string. digits indicates the format of the digits. It can be an alias as: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} or a DigitsOptions object with some or all of the following properties: minimumIntegerDigits The minimum number of integer digits to use. minimumFractionDigits The minimum number of fraction digits to use. maximumFractionDigits The maximum number of fraction digits to use. minimumSignificantDigits The minimum number of significant digits to use. maximumSignificantDigits The maximum number of significant digits to use. useGrouping Whether to use grouping separators, such as thousands separators. See Intl.NumberFormat for further information. {{ value | l10nDecimal:defaultLocale:'1.5-5' }} Percentages expression | l10nPercent[:defaultLocale:[digits]] {{ value | l10nPercent:defaultLocale:'1.1-1' }} Currencies expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digits]]]] where currencyDisplay is the currency formatting. Possible values are 'symbol' to use a localized currency symbol such as \u20ac , 'code' to use the ISO currency code, 'name' to use a localized currency name such as dollar ; the default is 'symbol' . {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }} Extended classes When using pipes , alternatively to decorators you can extend Translation or Localization classes. Extend Translation class in the component to provide lang to translate pipe: export class HomeComponent extends Translation { } Extend Localization class in the component to provide lang to translate pipe, defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent l10nCurrency pipes. export class HomeComponent extends Localization { } OnPush Change detection strategy Pure pipes don't need to set ChangeDetectionStrategy to OnPush . If into your components you need to use it, you have to inject ChangeDetectorRef : @Component({ ... changeDetection: ChangeDetectionStrategy.OnPush }) export class HomeComponent implements OnInit { @Language() lang: string; constructor(private cdr: ChangeDetectorRef) { } ngOnInit(): void { } } Or if you use extended classes: export class HomeComponent extends Translation { constructor(private cdr: ChangeDetectorRef) { super(cdr); } } That's because we need to know the component reference that implements the OnPush strategy. Note that if you use in the component only the directives and not the pipes , you don't need to inject ChangeDetectorRef . Directives Directive Selectors Translate l10nTranslate , translate L10nDate l10nDate L10nDecimal l10nDecimal L10nPercent l10nPercent L10nCurrency l10nCurrency Directive Type Format Html syntax Translate Message String tag l10n-attribute attribute=\"expr1\" [params]=\"[params]\" l10nTranslate expr2 /tag L10nDate Date Date/Number/ISO string tag l10n-attribute attribute=\"expr1\" format=\"[format]\" l10nDate expr2 /tag L10nDecimal Decimal Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" l10nDecimal expr2 /tag L10nPercent Percentage Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" l10nPercent expr2 /tag L10nCurrency Currency Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" currencyDisplay=\"[currencyDisplay]\" l10nCurrency expr2 /tag You can dynamically change parameters and expressions values as with pipes. How does it work? To observe the expression change (not the parameters), a MutationObserver is used: the observer is added only if detected in the browser. If you want to use this feature also reaching older browsers, we recommend using pipes. If you use in the component only the directives and not the pipes, you don't need to use decorators. Messages h1 l10nTranslate title /h1 Parameters p [params]= { user: username, NoMessages: messages.length } l10nTranslate userNotifications /p Dates Numbers p l10nDate {{ today }} /p p format= fullDate l10nDate {{ today }} /p p l10nDecimal {{ value }} /p p digits= 1.5-5 l10nDecimal {{ value }} /p p l10nPercent {{ value }} /p p digits= 1.1-1 l10nPercent {{ value }} /p p l10nCurrency {{ value }} /p p digits= 1.2-2 currencyDisplay= symbol l10nCurrency {{ value }} /p Attributes p l10n-title title= greeting l10nTranslate title /p All attributes will be translated according to the master directive: l10nTranslate , l10nDate and so on. You can't dynamically change expressions in attributes. Parameters p l10n-title title= greeting [params]= { user: username, NoMessages: messages.length } l10nTranslate userNotifications /p JSON : { greeting : Hi {{ user }} , userNotifications : {{ user }}, you have {{ NoMessages }} new messages } UI components You can properly translate UI components like Angular Material or Ionic: a mat-list-item routerLinkActive= active-link routerLink= /home l10nTranslate app.home /a rendered as: a class= mat-list-item ng-star-inserted active-link l10ntranslate= mat-list-item= role= listitem routerlinkactive= active-link href= #/home style= div class= mat-list-item-content div class= mat-list-item-ripple mat-ripple mat-ripple= /div div class= mat-list-text /div Home /div /a How does it work? The algorithm searches the text in the subtree. If there is a depth higher than 4 (in the example above the text to translate has a depth 2), we recommend using pipes. Using Html tags in translation If you have Html tags in translation like this: strongSubtitle : strong It's a small world /strong you have to use innerHTML property. Using pipes : p [innerHTML]= 'strongSubtitle' | translate:lang /p Using directives : p [innerHTML]= 'strongSubtitle' l10nTranslate /p Pluralization The library implements pluralization through the official i18nPluralPipe . Just add to it the translate pipe: p {{ messages.length | i18nPlural:messageMapping | translate:lang }} /p or the directive: p l10nTranslate {{ messages.length | i18nPlural:messageMapping }} /p and enable i18nPlural option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... i18nPlural: true } }; Getting the translation in component class Messages To get the translation in component class, TranslationService has the following methods: translate(keys: string | string[], args?: any, lang?: string): string | any translateAsync(keys: string | string[], args?: any, lang?: string): Observable string | any When you use those methods, you must be sure that the Http request is completed , and the translation file has been loaded: @Component({ ... template: ` h1 {{ title }} /h1 button (click)= getTranslation() Translate /button ` }) export class HomeComponent { title: string; constructor(private translation: TranslationService) { } getTranslation(): void { this.title = this.translation.translate('title'); } } To get the translation when the component is loaded and when the current language changes , you must subscribe to the following method: translationChanged(): Observable string @Component({ ... template: ` h1 {{ title }} /h1 ` }) export class HomeComponent implements OnInit { title: string; constructor(private translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } } Dates numbers To get the translation of dates and numbers, LocaleService has the following methods: formatDate(value: any, format?: string | DateTimeOptions, defaultLocale?: string, timezone?: string): string formatDecimal(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string formatPercent(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string formatCurrency(value: any, digits?: string | DigitsOptions, currencyDisplay?: string, defaultLocale?: string, currency?: string): string Handle the translation The default translation handler does not perform operations on the translated values: it handles the missing keys returning the path of the key or the value set by missingValue during the configuration, and replaces parameters. To perform custom operations, you can implement TranslationHandler class-interface and the parseValue method: @Injectable() export class CustomTranslationHandler implements TranslationHandler { /** * This method must contain the logic to parse the translated value. * @param path The path of the key * @param key The key that has been requested * @param value The translated value * @param args The parameters passed along with the key * @param lang The current language * @return The parsed value */ public parseValue(path: string, key: string, value: string | null, args: any, lang: string): string { .. return ... } } Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationHandler: CustomTranslationHandler } ) ], ... }) See also TranslationHandler code. Changing language, default locale, currency or timezone at runtime To change language, default locale, currency or timezone at runtime, LocaleService has the following methods: setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void","title":"Getting the translation"},{"location":"spec/getting-the-translation/#getting-the-translation","text":"To get the translation, this library uses pure pipes (to know the difference between pure and impure pipes see here ) or directives . You can also get the translation in component class.","title":"Getting the translation"},{"location":"spec/getting-the-translation/#pure-pipes","text":"Pipe Type Format Pipe syntax Translate Message String expression | translate:lang L10nDate Date Date/Number/ISO string expression | l10nDate[:defaultLocale[:format[:timezone]]] L10nDecimal Decimal Number/string expression | l10nDecimal[:defaultLocale[:digits]] L10nPercent Percentage Number/string expression | l10nPercent[:defaultLocale[:digits]] L10nCurrency Currency Number/string expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digits]]]] You can dynamically change parameters and expressions values.","title":"Pure pipes"},{"location":"spec/getting-the-translation/#messages","text":"Implement Language decorator in the component to provide the parameter to translate pipe: export class HomeComponent implements OnInit { @Language() lang: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty. expression | translate:lang where expression is a string key that indicates the message to translate: {{ 'title' | translate:lang }} JSON : { title : Angular localization }","title":"Messages"},{"location":"spec/getting-the-translation/#composed-keys","text":"Set composedKeySeparator during the configuration, e.g. to '.' : {{ 'home.title' | translate:lang }} JSON : { home : { title : Angular localization } }","title":"Composed keys"},{"location":"spec/getting-the-translation/#parameters","text":"{{ 'userNotifications' | translate:lang:{ user: username, NoMessages: messages.length } }} JSON : { userNotifications : {{ user }}, you have {{ NoMessages }} new messages }","title":"Parameters"},{"location":"spec/getting-the-translation/#dates-numbers","text":"Implement DefaultLocale , Currency optionally Timezone decorators in the component to provide defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent l10nCurrency pipes. export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Currency() currency: string; @Timezone() timezone: string; ngOnInit(): void { } } To use AoT compilation you have to implement OnInit, and to cancel subscriptions OnDestroy, even if they are empty.","title":"Dates &amp; Numbers"},{"location":"spec/getting-the-translation/#dates","text":"expression | l10nDate[:defaultLocale[:format[:timezone]]] where: expression is a date object or a number (milliseconds since UTC epoch) or an ISO string. format indicates which date/time components to include. The format can be an alias as shown below: 'short' : equivalent to 'M/d/y, h:mm' (e.g. 8/29/2017, 4:37 PM for en-US ) 'medium' : equivalent to 'MMM d, y, h:mm:ss' (e.g. Aug 29, 2017, 4:32:43 PM for en-US ) 'long' : equivalent to 'MMMM d, y, h:mm:ss' (e.g. August 29, 2017, 4:32:43 PM for en-US ) 'shortDate' : equivalent to 'M/d/y' (e.g. 8/29/2017 for en-US ) 'mediumDate' : equivalent to 'MMM d, y' (e.g. Aug 29, 2017 for en-US ) 'longDate' : equivalent to 'MMMM d, y' (e.g. August 29, 2017 for en-US ) 'fullDate' : equivalent to 'EEEE, MMMM d, y' (e.g. Tuesday, August 29, 2017 for en-US ) 'shortTime' : equivalent to 'h:mm' (e.g. 4:53 PM for en-US ) 'mediumTime' : equivalent to 'h:mm:ss' (e.g. 4:54:15 PM for en-US ) It can also be a DateTimeOptions object with some or all of the following properties: weekday The representation of the weekday. Possible values are narrow , short , long . era The representation of the era. Possible values are narrow , short , long . year The representation of the year. Possible values are numeric , 2-digit . month The representation of the month. Possible values are numeric , 2-digit , narrow , short , long . day The representation of the day. Possible values are numeric , 2-digit . hour The representation of the hour. Possible values are numeric , 2-digit . minute The representation of the minute. Possible values are numeric , 2-digit . second The representation of the second. Possible values are numeric , 2-digit . timeZoneName The representation of the time zone name. Possible values are short , long . hour12 Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent. See Intl.DateTimeFormat for further information.","title":"Dates"},{"location":"spec/getting-the-translation/#using-format-aliases","text":"{{ today | l10nDate:defaultLocale:'fullDate' }}","title":"Using format aliases"},{"location":"spec/getting-the-translation/#using-a-custom-format","text":"@Component({ template: ` p {{ today | l10nDate:defaultLocale:options }} /p ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; today: Date = new Date(); options: DateTimeOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; ngOnInit(): void { } }","title":"Using a custom format"},{"location":"spec/getting-the-translation/#using-timezone","text":"@Component({ template: ` p {{ today | l10nDate:defaultLocale:'medium':timezone }} /p ` }) export class HomeComponent implements OnInit { @DefaultLocale() defaultLocale: string; @Timezone() timezone: string; today: Date = new Date(); ngOnInit(): void { } }","title":"Using timezone"},{"location":"spec/getting-the-translation/#decimals","text":"expression | l10nDecimal[:defaultLocale:[digits]] where: expression is a number or a string. digits indicates the format of the digits. It can be an alias as: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} or a DigitsOptions object with some or all of the following properties: minimumIntegerDigits The minimum number of integer digits to use. minimumFractionDigits The minimum number of fraction digits to use. maximumFractionDigits The maximum number of fraction digits to use. minimumSignificantDigits The minimum number of significant digits to use. maximumSignificantDigits The maximum number of significant digits to use. useGrouping Whether to use grouping separators, such as thousands separators. See Intl.NumberFormat for further information. {{ value | l10nDecimal:defaultLocale:'1.5-5' }}","title":"Decimals"},{"location":"spec/getting-the-translation/#percentages","text":"expression | l10nPercent[:defaultLocale:[digits]] {{ value | l10nPercent:defaultLocale:'1.1-1' }}","title":"Percentages"},{"location":"spec/getting-the-translation/#currencies","text":"expression | l10nCurrency[:defaultLocale[:currency[:currencyDisplay[:digits]]]] where currencyDisplay is the currency formatting. Possible values are 'symbol' to use a localized currency symbol such as \u20ac , 'code' to use the ISO currency code, 'name' to use a localized currency name such as dollar ; the default is 'symbol' . {{ value | l10nCurrency:defaultLocale:currency:'symbol':'1.2-2' }}","title":"Currencies"},{"location":"spec/getting-the-translation/#extended-classes","text":"When using pipes , alternatively to decorators you can extend Translation or Localization classes. Extend Translation class in the component to provide lang to translate pipe: export class HomeComponent extends Translation { } Extend Localization class in the component to provide lang to translate pipe, defaultLocale , currency , timezone to l10nDate , l10nDecimal , l10nPercent l10nCurrency pipes. export class HomeComponent extends Localization { }","title":"Extended classes"},{"location":"spec/getting-the-translation/#onpush-change-detection-strategy","text":"Pure pipes don't need to set ChangeDetectionStrategy to OnPush . If into your components you need to use it, you have to inject ChangeDetectorRef : @Component({ ... changeDetection: ChangeDetectionStrategy.OnPush }) export class HomeComponent implements OnInit { @Language() lang: string; constructor(private cdr: ChangeDetectorRef) { } ngOnInit(): void { } } Or if you use extended classes: export class HomeComponent extends Translation { constructor(private cdr: ChangeDetectorRef) { super(cdr); } } That's because we need to know the component reference that implements the OnPush strategy. Note that if you use in the component only the directives and not the pipes , you don't need to inject ChangeDetectorRef .","title":"OnPush Change detection strategy"},{"location":"spec/getting-the-translation/#directives","text":"Directive Selectors Translate l10nTranslate , translate L10nDate l10nDate L10nDecimal l10nDecimal L10nPercent l10nPercent L10nCurrency l10nCurrency Directive Type Format Html syntax Translate Message String tag l10n-attribute attribute=\"expr1\" [params]=\"[params]\" l10nTranslate expr2 /tag L10nDate Date Date/Number/ISO string tag l10n-attribute attribute=\"expr1\" format=\"[format]\" l10nDate expr2 /tag L10nDecimal Decimal Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" l10nDecimal expr2 /tag L10nPercent Percentage Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" l10nPercent expr2 /tag L10nCurrency Currency Number/string tag l10n-attribute attribute=\"expr1\" digits=\"[digits]\" currencyDisplay=\"[currencyDisplay]\" l10nCurrency expr2 /tag You can dynamically change parameters and expressions values as with pipes. How does it work? To observe the expression change (not the parameters), a MutationObserver is used: the observer is added only if detected in the browser. If you want to use this feature also reaching older browsers, we recommend using pipes. If you use in the component only the directives and not the pipes, you don't need to use decorators.","title":"Directives"},{"location":"spec/getting-the-translation/#messages_1","text":"h1 l10nTranslate title /h1","title":"Messages"},{"location":"spec/getting-the-translation/#parameters_1","text":"p [params]= { user: username, NoMessages: messages.length } l10nTranslate userNotifications /p","title":"Parameters"},{"location":"spec/getting-the-translation/#dates-numbers_1","text":"p l10nDate {{ today }} /p p format= fullDate l10nDate {{ today }} /p p l10nDecimal {{ value }} /p p digits= 1.5-5 l10nDecimal {{ value }} /p p l10nPercent {{ value }} /p p digits= 1.1-1 l10nPercent {{ value }} /p p l10nCurrency {{ value }} /p p digits= 1.2-2 currencyDisplay= symbol l10nCurrency {{ value }} /p","title":"Dates &amp; Numbers"},{"location":"spec/getting-the-translation/#attributes","text":"p l10n-title title= greeting l10nTranslate title /p All attributes will be translated according to the master directive: l10nTranslate , l10nDate and so on. You can't dynamically change expressions in attributes.","title":"Attributes"},{"location":"spec/getting-the-translation/#parameters_2","text":"p l10n-title title= greeting [params]= { user: username, NoMessages: messages.length } l10nTranslate userNotifications /p JSON : { greeting : Hi {{ user }} , userNotifications : {{ user }}, you have {{ NoMessages }} new messages }","title":"Parameters"},{"location":"spec/getting-the-translation/#ui-components","text":"You can properly translate UI components like Angular Material or Ionic: a mat-list-item routerLinkActive= active-link routerLink= /home l10nTranslate app.home /a rendered as: a class= mat-list-item ng-star-inserted active-link l10ntranslate= mat-list-item= role= listitem routerlinkactive= active-link href= #/home style= div class= mat-list-item-content div class= mat-list-item-ripple mat-ripple mat-ripple= /div div class= mat-list-text /div Home /div /a How does it work? The algorithm searches the text in the subtree. If there is a depth higher than 4 (in the example above the text to translate has a depth 2), we recommend using pipes.","title":"UI components"},{"location":"spec/getting-the-translation/#using-html-tags-in-translation","text":"If you have Html tags in translation like this: strongSubtitle : strong It's a small world /strong you have to use innerHTML property. Using pipes : p [innerHTML]= 'strongSubtitle' | translate:lang /p Using directives : p [innerHTML]= 'strongSubtitle' l10nTranslate /p","title":"Using Html tags in translation"},{"location":"spec/getting-the-translation/#pluralization","text":"The library implements pluralization through the official i18nPluralPipe . Just add to it the translate pipe: p {{ messages.length | i18nPlural:messageMapping | translate:lang }} /p or the directive: p l10nTranslate {{ messages.length | i18nPlural:messageMapping }} /p and enable i18nPlural option during the configuration: const l10nConfig: L10nConfig = { ... translation: { ... i18nPlural: true } };","title":"Pluralization"},{"location":"spec/getting-the-translation/#getting-the-translation-in-component-class","text":"","title":"Getting the translation in component class"},{"location":"spec/getting-the-translation/#messages_2","text":"To get the translation in component class, TranslationService has the following methods: translate(keys: string | string[], args?: any, lang?: string): string | any translateAsync(keys: string | string[], args?: any, lang?: string): Observable string | any When you use those methods, you must be sure that the Http request is completed , and the translation file has been loaded: @Component({ ... template: ` h1 {{ title }} /h1 button (click)= getTranslation() Translate /button ` }) export class HomeComponent { title: string; constructor(private translation: TranslationService) { } getTranslation(): void { this.title = this.translation.translate('title'); } } To get the translation when the component is loaded and when the current language changes , you must subscribe to the following method: translationChanged(): Observable string @Component({ ... template: ` h1 {{ title }} /h1 ` }) export class HomeComponent implements OnInit { title: string; constructor(private translation: TranslationService) { } ngOnInit(): void { this.translation.translationChanged().subscribe( () = { this.title = this.translation.translate('title'); } ); } }","title":"Messages"},{"location":"spec/getting-the-translation/#dates-numbers_2","text":"To get the translation of dates and numbers, LocaleService has the following methods: formatDate(value: any, format?: string | DateTimeOptions, defaultLocale?: string, timezone?: string): string formatDecimal(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string formatPercent(value: any, digits?: string | DigitsOptions, defaultLocale?: string): string formatCurrency(value: any, digits?: string | DigitsOptions, currencyDisplay?: string, defaultLocale?: string, currency?: string): string","title":"Dates &amp; numbers"},{"location":"spec/getting-the-translation/#handle-the-translation","text":"The default translation handler does not perform operations on the translated values: it handles the missing keys returning the path of the key or the value set by missingValue during the configuration, and replaces parameters. To perform custom operations, you can implement TranslationHandler class-interface and the parseValue method: @Injectable() export class CustomTranslationHandler implements TranslationHandler { /** * This method must contain the logic to parse the translated value. * @param path The path of the key * @param key The key that has been requested * @param value The translated value * @param args The parameters passed along with the key * @param lang The current language * @return The parsed value */ public parseValue(path: string, key: string, value: string | null, args: any, lang: string): string { .. return ... } } Then provide the class in the module: @NgModule({ imports: [ ... TranslationModule.forRoot( l10nConfig, { translationHandler: CustomTranslationHandler } ) ], ... }) See also TranslationHandler code.","title":"Handle the translation"},{"location":"spec/getting-the-translation/#changing-language-default-locale-currency-or-timezone-at-runtime","text":"To change language, default locale, currency or timezone at runtime, LocaleService has the following methods: setCurrentLanguage(languageCode: string): void setDefaultLocale(languageCode: string, countryCode?: string, scriptCode?: string, numberingSystem?: string, calendar?: string): void setCurrentCurrency(currencyCode: string): void setCurrentTimezone(zoneName: string): void","title":"Changing language, default locale, currency or timezone at runtime"},{"location":"spec/interceptor/","text":"Setting the locale in Accept-Language header Import the module in the application root module: @NgModule({ imports: [ ... LocaleInterceptorModule ], ... }) export class AppModule { } To set the locale in Accept-Language header on all outgoing requests, provide the localeInterceptor option during the configuration: const l10nConfig: L10nConfig = { ... localeInterceptor: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] } };","title":"Setting the locale in Accept-Language header"},{"location":"spec/interceptor/#setting-the-locale-in-accept-language-header","text":"Import the module in the application root module: @NgModule({ imports: [ ... LocaleInterceptorModule ], ... }) export class AppModule { } To set the locale in Accept-Language header on all outgoing requests, provide the localeInterceptor option during the configuration: const l10nConfig: L10nConfig = { ... localeInterceptor: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] } };","title":"Setting the locale in Accept-Language header"},{"location":"spec/lazy-loading/","text":"Lazy loaded modules Shared modules Lazy loaded modules You can create an instance of TranslationService with its own translation data for every lazy loaded module, as shown: You can create a new instance of TranslationService calling the forChild method of the module you are using, and configure the service with the new providers: const l10nConfig: L10nConfig = { translation: { providers: [ { type: ProviderType.Static, prefix: './src/assets/locale-' }, { type: ProviderType.Static, prefix: './src/assets/locale-list-' } ], ... } }; @NgModule({ imports: [ ... TranslationModule.forChild(l10nConfig) // New instance of TranslationService. ], declarations: [ListComponent] }) export class ListModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } } If you use a global file shared across lazy loaded modules , you can enable the caching during the configuration in AppModule . In this way, application performance and memory usage are optimized. Shared modules If you don't want a new instance of TranslationService with its own translation data for each feature module, but you want it to be singleton and shared by other modules, you have to call forRoot method of the module you are using once in AppModule : @NgModule({ imports: [ ... SharedModule, TranslationModule.forRoot(l10nConfig) ], ... }) export class AppModule { } Import/export TranslationModule or LocalizationModule without methods in a shared module: const sharedModules: any[] = [ ... TranslationModule ]; @NgModule({ imports: sharedModules, exports: sharedModules }) export class SharedModule { } Then in the feature module (also if it is lazy loaded ): @NgModule({ imports: [ ... SharedModule ], ... }) export class ListModule { } You must provide the configuration only in AppModule .","title":"Lazy loaded modules & Shared modules"},{"location":"spec/lazy-loading/#lazy-loaded-modules-shared-modules","text":"","title":"Lazy loaded modules &amp; Shared modules"},{"location":"spec/lazy-loading/#lazy-loaded-modules","text":"You can create an instance of TranslationService with its own translation data for every lazy loaded module, as shown: You can create a new instance of TranslationService calling the forChild method of the module you are using, and configure the service with the new providers: const l10nConfig: L10nConfig = { translation: { providers: [ { type: ProviderType.Static, prefix: './src/assets/locale-' }, { type: ProviderType.Static, prefix: './src/assets/locale-list-' } ], ... } }; @NgModule({ imports: [ ... TranslationModule.forChild(l10nConfig) // New instance of TranslationService. ], declarations: [ListComponent] }) export class ListModule { constructor(private l10nLoader: L10nLoader) { this.l10nLoader.load(); } } If you use a global file shared across lazy loaded modules , you can enable the caching during the configuration in AppModule . In this way, application performance and memory usage are optimized.","title":"Lazy loaded modules"},{"location":"spec/lazy-loading/#shared-modules","text":"If you don't want a new instance of TranslationService with its own translation data for each feature module, but you want it to be singleton and shared by other modules, you have to call forRoot method of the module you are using once in AppModule : @NgModule({ imports: [ ... SharedModule, TranslationModule.forRoot(l10nConfig) ], ... }) export class AppModule { } Import/export TranslationModule or LocalizationModule without methods in a shared module: const sharedModules: any[] = [ ... TranslationModule ]; @NgModule({ imports: sharedModules, exports: sharedModules }) export class SharedModule { } Then in the feature module (also if it is lazy loaded ): @NgModule({ imports: [ ... SharedModule ], ... }) export class ListModule { } You must provide the configuration only in AppModule .","title":"Shared modules"},{"location":"spec/library-structure/","text":"Library structure Main modules Class Contract TranslationModule Provides dependencies, pipes directives for translating messages LocalizationModule Provides dependencies, pipes directives for translating messages, dates numbers LocaleValidationModule Provides dependencies directives for validation by locales LocaleSeoModule Provides dependencies components for SEO by locales CollatorModule Provides dependencies for sorting and filtering a list by locales LocaleInterceptorModule Sets locale in Accept-Language header on outgoing requests Main services Class Contract L10nLoader Initializes the services LocaleService Manages language, default locale, currency timezone TranslationService Manages the translation data LocaleValidation Provides the methods for locale validation SearchService Manages the translation of page 'title' and meta tags Collator Intl.Collator APIs IntlAPI Provides the methods to check if Intl APIs are supported Main class-interfaces Class Contract LocaleStorage Class-interface to create a custom storage for default locale, currency timezone TranslationProvider Class-interface to create a custom provider for translation data TranslationHandler Class-interface to create a custom handler for translated values","title":"Library structure"},{"location":"spec/library-structure/#library-structure","text":"","title":"Library structure"},{"location":"spec/library-structure/#main-modules","text":"Class Contract TranslationModule Provides dependencies, pipes directives for translating messages LocalizationModule Provides dependencies, pipes directives for translating messages, dates numbers LocaleValidationModule Provides dependencies directives for validation by locales LocaleSeoModule Provides dependencies components for SEO by locales CollatorModule Provides dependencies for sorting and filtering a list by locales LocaleInterceptorModule Sets locale in Accept-Language header on outgoing requests","title":"Main modules"},{"location":"spec/library-structure/#main-services","text":"Class Contract L10nLoader Initializes the services LocaleService Manages language, default locale, currency timezone TranslationService Manages the translation data LocaleValidation Provides the methods for locale validation SearchService Manages the translation of page 'title' and meta tags Collator Intl.Collator APIs IntlAPI Provides the methods to check if Intl APIs are supported","title":"Main services"},{"location":"spec/library-structure/#main-class-interfaces","text":"Class Contract LocaleStorage Class-interface to create a custom storage for default locale, currency timezone TranslationProvider Class-interface to create a custom provider for translation data TranslationHandler Class-interface to create a custom handler for translated values","title":"Main class-interfaces"},{"location":"spec/seo/","text":"SEO by locales Import the modules you need in the application root module: @NgModule({ imports: [ ... TranslationModule.forRoot(l10nConfig) LocaleSeoModule.forRoot() ], ... }) export class AppModule { } The order is important: always import LocaleSeoModule after TranslationModule or LocalizationModule . Localized routing In locale-adaptive apps (like the apps that use this library, that return different content based on the preferred locale of the visitor), Google might not crawl, index, or rank all the content for different locales . To solve this problem, you can enable localized routing during configuration: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] } }; Features: A prefix is added to the path of each navigation, containing the language or the locale, creating a semantic URL: baseHref[language[-script][-country]]path https://example.com/en/home https://example.com/en-US/home If the localized link is called, the content is automatically translated. When the language changes, the link is also updated. Changes to localized links do not change browser history. It works also with SSR. To achieve this, the router configuration in your app is not rewritten (operation that would poor performance and could cause errors): the Location class provided by Angular is used for the replacement of the URL, in order to provide the different contents localized both to the crawlers and to the users that can refer to the localized links. Since the link contains only the locale, if your app also uses numbering system , calendar , currency or timezone , you should set schema option below. Using hreflang and sitemap You can use the sitemap to tell Google all of the locale variants for each URL: ?xml version= 1.0 encoding= utf-8 ? urlset xmlns= http://www.sitemaps.org/schemas/sitemap/0.9 xmlns:xhtml= http://www.w3.org/1999/xhtml url loc https://example.com/en/home /loc xhtml:link rel= alternate hreflang= it href= https://example.com/en/home / xhtml:link rel= alternate hreflang= en href= https://example.com/it/home / ... xhtml:link rel= alternate hreflang= x-default href= https://example.com/home / /url url loc https://example.com/it/home /loc ... /url ... /urlset For more info, visit Search Console Help - International Default routing If you don't want a localized routing for default language or locale, you can enable it during the configuration: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], defaultRouting: true } }; Schema If your app uses numbering system , calendar , currency or timezone , it is recommended to provide the schema option, to manage the localized links and refreshes: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, ISOCode.Country], schema: [ { text: 'United States', languageCode: 'en', countryCode: 'US', currency: 'USD' }, { text: 'Italia', languageCode: 'it', countryCode: 'IT', currency: 'EUR' }, ] } }; Translation of title and meta tags To translate the title and other meta tags you can use the updateHead method of SearchService , passing the key path of the page: class HomeComponent implements OnInit { constructor(private search: SearchService) { } ngOnInit(): void { this.search.updateHead('home'); } } Basically, only the title is translated. To translate meta tags, you must pass them during configuration: const l10nConfig: L10nConfig = { ... translation: { ... composedKeySeparator: '.' }, search: { metaTags: ['description'] } }; JSON : { home : { title : Angular localization , description : An Angular library to translate messages, dates and numbers } } Translation of JSON-LD structured data To translate structured data in JSON-LD format, you can use the l10n-json-ld component, passing the key path of the schema: @Component({ template: ` l10n-json-ld path= corporationSchema /l10n-json-ld ` }) class HomeComponent { } JSON : { corporationSchema : { @context : http://schema.org , @type : Corporation , name : New Artisan , description : Design and development of web applications } } Note that Google Structured Data Testing tool won't work, because it only renders index.html , but the crawlers do.","title":"SEO by locales"},{"location":"spec/seo/#seo-by-locales","text":"Import the modules you need in the application root module: @NgModule({ imports: [ ... TranslationModule.forRoot(l10nConfig) LocaleSeoModule.forRoot() ], ... }) export class AppModule { } The order is important: always import LocaleSeoModule after TranslationModule or LocalizationModule .","title":"SEO by locales"},{"location":"spec/seo/#localized-routing","text":"In locale-adaptive apps (like the apps that use this library, that return different content based on the preferred locale of the visitor), Google might not crawl, index, or rank all the content for different locales . To solve this problem, you can enable localized routing during configuration: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */] } }; Features: A prefix is added to the path of each navigation, containing the language or the locale, creating a semantic URL: baseHref[language[-script][-country]]path https://example.com/en/home https://example.com/en-US/home If the localized link is called, the content is automatically translated. When the language changes, the link is also updated. Changes to localized links do not change browser history. It works also with SSR. To achieve this, the router configuration in your app is not rewritten (operation that would poor performance and could cause errors): the Location class provided by Angular is used for the replacement of the URL, in order to provide the different contents localized both to the crawlers and to the users that can refer to the localized links. Since the link contains only the locale, if your app also uses numbering system , calendar , currency or timezone , you should set schema option below.","title":"Localized routing"},{"location":"spec/seo/#using-hreflang-and-sitemap","text":"You can use the sitemap to tell Google all of the locale variants for each URL: ?xml version= 1.0 encoding= utf-8 ? urlset xmlns= http://www.sitemaps.org/schemas/sitemap/0.9 xmlns:xhtml= http://www.w3.org/1999/xhtml url loc https://example.com/en/home /loc xhtml:link rel= alternate hreflang= it href= https://example.com/en/home / xhtml:link rel= alternate hreflang= en href= https://example.com/it/home / ... xhtml:link rel= alternate hreflang= x-default href= https://example.com/home / /url url loc https://example.com/it/home /loc ... /url ... /urlset For more info, visit Search Console Help - International","title":"Using hreflang and sitemap"},{"location":"spec/seo/#default-routing","text":"If you don't want a localized routing for default language or locale, you can enable it during the configuration: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, /* ISOCode.Script, */ /* ISOCode.Country */], defaultRouting: true } };","title":"Default routing"},{"location":"spec/seo/#schema","text":"If your app uses numbering system , calendar , currency or timezone , it is recommended to provide the schema option, to manage the localized links and refreshes: const l10nConfig: L10nConfig = { ... localizedRouting: { format: [ISOCode.Language, ISOCode.Country], schema: [ { text: 'United States', languageCode: 'en', countryCode: 'US', currency: 'USD' }, { text: 'Italia', languageCode: 'it', countryCode: 'IT', currency: 'EUR' }, ] } };","title":"Schema"},{"location":"spec/seo/#translation-of-title-and-meta-tags","text":"To translate the title and other meta tags you can use the updateHead method of SearchService , passing the key path of the page: class HomeComponent implements OnInit { constructor(private search: SearchService) { } ngOnInit(): void { this.search.updateHead('home'); } } Basically, only the title is translated. To translate meta tags, you must pass them during configuration: const l10nConfig: L10nConfig = { ... translation: { ... composedKeySeparator: '.' }, search: { metaTags: ['description'] } }; JSON : { home : { title : Angular localization , description : An Angular library to translate messages, dates and numbers } }","title":"Translation of title and meta tags"},{"location":"spec/seo/#translation-of-json-ld-structured-data","text":"To translate structured data in JSON-LD format, you can use the l10n-json-ld component, passing the key path of the schema: @Component({ template: ` l10n-json-ld path= corporationSchema /l10n-json-ld ` }) class HomeComponent { } JSON : { corporationSchema : { @context : http://schema.org , @type : Corporation , name : New Artisan , description : Design and development of web applications } } Note that Google Structured Data Testing tool won't work, because it only renders index.html , but the crawlers do.","title":"Translation of JSON-LD structured data"},{"location":"spec/testing/","text":"Unit testing There are several ways to test an app that implements this library. To provide the data, you could use: a MockBackend real services mock services During the configuration of Jasmine , you could do something like this: describe('Component: HomeComponent', () = { let fixture: ComponentFixture HomeComponent ; let comp: HomeComponent; let l10nLoader: L10nLoader; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Disabled }, translation: { providers: [ { type: ProviderType.Static, prefix: '/assets/locale-' } ], ... } }; beforeEach(async () = { TestBed.configureTestingModule({ imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [HomeComponent] }).compileComponents(); fixture = TestBed.createComponent(HomeComponent); comp = fixture.componentInstance; }); beforeEach((done: any) = { l10nLoader = TestBed.get(L10nLoader); l10nLoader.load().then(() = done()); }); it('should render translated text', (() = { fixture.detectChanges(); expect(...); })); }); In this case the real services are injected, importing LocalizationModule.forRoot method. The loading of configuration is in a dedicated beforeEach , that will be released only when the promise of the load method of L10nLoader will be resolved.","title":"Unit testing"},{"location":"spec/testing/#unit-testing","text":"There are several ways to test an app that implements this library. To provide the data, you could use: a MockBackend real services mock services During the configuration of Jasmine , you could do something like this: describe('Component: HomeComponent', () = { let fixture: ComponentFixture HomeComponent ; let comp: HomeComponent; let l10nLoader: L10nLoader; const l10nConfig: L10nConfig = { locale: { languages: [ { code: 'en', dir: 'ltr' } ], defaultLocale: { languageCode: 'en', countryCode: 'US' }, currency: 'USD', storage: StorageStrategy.Disabled }, translation: { providers: [ { type: ProviderType.Static, prefix: '/assets/locale-' } ], ... } }; beforeEach(async () = { TestBed.configureTestingModule({ imports: [ ... HttpClientModule, LocalizationModule.forRoot(l10nConfig) ], declarations: [HomeComponent] }).compileComponents(); fixture = TestBed.createComponent(HomeComponent); comp = fixture.componentInstance; }); beforeEach((done: any) = { l10nLoader = TestBed.get(L10nLoader); l10nLoader.load().then(() = done()); }); it('should render translated text', (() = { fixture.detectChanges(); expect(...); })); }); In this case the real services are injected, importing LocalizationModule.forRoot method. The loading of configuration is in a dedicated beforeEach , that will be released only when the promise of the load method of L10nLoader will be resolved.","title":"Unit testing"},{"location":"spec/validation/","text":"Validation by locales Import the modules you need in the application root module: @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig), LocaleValidationModule.forRoot() ], declarations: [AppComponent], bootstrap: [AppComponent] }) export class AppModule { } Validating a number Directive Selectors L10nNumberValidator l10nValidateNumber Directive Validator Options Errors L10nNumberValidator digits=[digits] [minValue] [maxValue] format or minValue or maxValue where digits has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} , and minValue and maxValue attributes are optional: input digits= 1.2-2 minValue= 0 maxValue= 1000 name= decimal [(ngModel)]= decimal l10nValidateNumber or, if you use variables: input [digits]= digits [minValue]= minValue [maxValue]= maxValue name= decimal [(ngModel)]= decimal l10nValidateNumber The number can be entered with or without the thousands separator. Parsing a number You can get the value of a localized number by the parseNumber method of LocaleValidation : parsedValue: number = null; constructor(private localeValidation: LocaleValidation) { } onSubmit(value: string): void { this.parsedValue = this.localeValidation.parseNumber(value); } FormBuilder If you use FormBuilder , you have to use the following validator function: l10nValidateNumber(digits: string, MIN_VALUE?: number, MAX_VALUE?: number): Function Defining a form: this.myForm = this.fb.group({ weight: ['', [ l10nValidateNumber('1.0-1') ]], height: ['', [ l10nValidateNumber('1.0-0', 50, 260) ]] }); On submit parse the values using parseNumber : const formValues = this.myForm.value; this.weight = this.localeValidation.parseNumber(formValues.weight); this.height = this.localeValidation.parseNumber(formValues.height); When first populating form data you have to format numbers before calling patchValue : const formValues = { weight: this.locale.formatDecimal(weight, '1.0-1'), height: this.locale.formatDecimal(height, '1.0-0') } this.myForm.patchValue(formValues);","title":"Validation by locales"},{"location":"spec/validation/#validation-by-locales","text":"Import the modules you need in the application root module: @NgModule({ imports: [ ... LocalizationModule.forRoot(l10nConfig), LocaleValidationModule.forRoot() ], declarations: [AppComponent], bootstrap: [AppComponent] }) export class AppModule { }","title":"Validation by locales"},{"location":"spec/validation/#validating-a-number","text":"Directive Selectors L10nNumberValidator l10nValidateNumber Directive Validator Options Errors L10nNumberValidator digits=[digits] [minValue] [maxValue] format or minValue or maxValue where digits has the following format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits} , and minValue and maxValue attributes are optional: input digits= 1.2-2 minValue= 0 maxValue= 1000 name= decimal [(ngModel)]= decimal l10nValidateNumber or, if you use variables: input [digits]= digits [minValue]= minValue [maxValue]= maxValue name= decimal [(ngModel)]= decimal l10nValidateNumber The number can be entered with or without the thousands separator.","title":"Validating a number"},{"location":"spec/validation/#parsing-a-number","text":"You can get the value of a localized number by the parseNumber method of LocaleValidation : parsedValue: number = null; constructor(private localeValidation: LocaleValidation) { } onSubmit(value: string): void { this.parsedValue = this.localeValidation.parseNumber(value); }","title":"Parsing a number"},{"location":"spec/validation/#formbuilder","text":"If you use FormBuilder , you have to use the following validator function: l10nValidateNumber(digits: string, MIN_VALUE?: number, MAX_VALUE?: number): Function Defining a form: this.myForm = this.fb.group({ weight: ['', [ l10nValidateNumber('1.0-1') ]], height: ['', [ l10nValidateNumber('1.0-0', 50, 260) ]] }); On submit parse the values using parseNumber : const formValues = this.myForm.value; this.weight = this.localeValidation.parseNumber(formValues.weight); this.height = this.localeValidation.parseNumber(formValues.height); When first populating form data you have to format numbers before calling patchValue : const formValues = { weight: this.locale.formatDecimal(weight, '1.0-1'), height: this.locale.formatDecimal(height, '1.0-0') } this.myForm.patchValue(formValues);","title":"FormBuilder"}]}