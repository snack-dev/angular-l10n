/**
 * ANGULAR 2 LOCALIZATION
 * An Angular 2 library to translate messages, dates and numbers.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular2localization
 */
System.register(['@angular/core', '@angular/http', 'rxjs/Observable', 'rxjs/add/operator/map', './locale.service', '../services/Intl-support'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var core_1, http_1, Observable_1, locale_service_1, Intl_support_1;
    var LocalizationService, ServiceState, LoadingMode;
    return {
        setters:[
            function (core_1_1) {
                core_1 = core_1_1;
            },
            function (http_1_1) {
                http_1 = http_1_1;
            },
            function (Observable_1_1) {
                Observable_1 = Observable_1_1;
            },
            function (_1) {},
            function (locale_service_1_1) {
                locale_service_1 = locale_service_1_1;
            },
            function (Intl_support_1_1) {
                Intl_support_1 = Intl_support_1_1;
            }],
        execute: function() {
            /**
             * LocalizationService class.
             *
             * Direct loading.
             *
             * To initialize LocalizationService for the direct loading, add the following code in the body of constructor of the route component:
             *
             * var translationEN = {
             *      TITLE: 'Angular 2 Localization',
             *      CHANGE_LANGUAGE: 'Change language',
             *      ...
             * }
             * // Add a new translation here.
             *
             * // Required: adds a new translation with the given language code.
             * this.localization.addTranslation('en', translationEN);
             * // Add a new translation with the given language code here.
             * this.localization.updateTranslation(); // Need to update the translation.
             *
             * Asynchronous loading.
             *
             * To initialize LocalizationService for the asynchronous loading, add the following code in the body of constructor of the route component:
             *
             * // Required: initializes the translation provider with the given path prefix.
             * this.localization.translationProvider('./resources/locale-');
             * this.localization.updateTranslation(); // Need to update the translation.
             *
             * and create the json files of the translations such as 'locale-en.json':
             *
             * {
             *     "TITLE": "Angular 2 Localization",
             *     "CHANGE_LANGUAGE": "Change language",
             *     ...
             * }
             *
             * @author Roberto Simonetti
             */
            LocalizationService = (function () {
                function LocalizationService(http, locale) {
                    this.http = http;
                    this.locale = locale;
                    /**
                     * The translation data: {languageCode: {key: value}}.
                     */
                    this.translationData = {};
                    this.prefix = "";
                    this.loadingMode = LoadingMode.Unknown;
                    this.languageCode = "";
                    // Initializes the loading mode.
                    this.loadingMode = LoadingMode.Direct;
                    // Initializes the service state.
                    this.serviceState = ServiceState.isWaiting;
                }
                /**
                 * Direct loading: adds new translation data.
                 *
                 * @param language The two-letter code of the language for the translation data
                 * @param translation The new translation data
                 */
                LocalizationService.prototype.addTranslation = function (language, translation) {
                    // Adds the new translation data.
                    this.translationData[language] = translation;
                };
                /**
                 * Asynchronous loading: defines the translation provider.
                 *
                 * @param prefix The path prefix of the json files
                 */
                LocalizationService.prototype.translationProvider = function (prefix) {
                    this.prefix = prefix;
                    // Updates the loading mode.
                    this.loadingMode = LoadingMode.Async;
                };
                /**
                 * Gets the json data.
                 */
                LocalizationService.prototype.getTranslation = function () {
                    var _this = this;
                    // Initializes the translation data & the service state.
                    this.translationData = {};
                    this.serviceState = ServiceState.isLoading;
                    var url = this.prefix + this.locale.getCurrentLanguage() + '.json';
                    // Angular 2 Http module.
                    this.http.get(url)
                        .map(function (res) { return res.json(); })
                        .subscribe(
                    // Observer or next.
                    function (res) {
                        // Assigns the observer to the translation data.
                        _this.translationData[_this.locale.getCurrentLanguage()] = res;
                    }, 
                    // Error.
                    function (error) {
                        console.error("Localization service:", error);
                    }, 
                    // Complete.
                    function () {
                        // Updates the language code of the service.
                        _this.languageCode = _this.locale.getCurrentLanguage();
                        // Updates the service state.
                        _this.serviceState = ServiceState.isReady;
                    });
                };
                /**
                 * Translates a key.
                 *
                 * @param key The key to be translated
                 * @return The value of translation
                 */
                LocalizationService.prototype.translate = function (key) {
                    var value;
                    if (this.translationData[this.languageCode] != null) {
                        // Gets the translation by language code. 
                        var translation = this.translationData[this.languageCode];
                        // Gets the value of translation by key.   
                        value = translation[key];
                    }
                    // If the value of translation is not present, the same key is returned (see issue #1).
                    if (value == null || value == "") {
                        value = key;
                    }
                    return value;
                };
                /**
                 * Translates a key.
                 *
                 * @param key The key to be translated
                 * @return An observable of the value of translation
                 */
                LocalizationService.prototype.translateAsync = function (key) {
                    var _this = this;
                    return new Observable_1.Observable(function (observer) {
                        // Gets the value of translation for the key.
                        var value = _this.translate(key);
                        observer.next(value);
                        observer.complete();
                    });
                };
                /**
                 * Updates the language code and loads the translation data for the asynchronous loading.
                 */
                LocalizationService.prototype.updateTranslation = function () {
                    if (this.locale.getCurrentLanguage() != "" && this.locale.getCurrentLanguage() != this.languageCode) {
                        // Asynchronous loading.
                        if (this.loadingMode == LoadingMode.Async) {
                            // Updates the translation data.  
                            this.getTranslation();
                        }
                        else {
                            // Updates the language code of the service.
                            this.languageCode = this.locale.getCurrentLanguage();
                            // Updates the service state.
                            this.serviceState = ServiceState.isReady;
                        }
                    }
                };
                /* Intl.Collator */
                /**
                 * Compares two keys by the value of translation & the current language code.
                 *
                 * @param key1, key2 The keys of the values to compare
                 * @param extension
                 * @param options
                 * @return A negative value if the value of translation of key1 comes before the value of translation of key2; a positive value if key1 comes after key2; 0 if they are considered equal or Intl.Collator is not supported
                 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
                 */
                LocalizationService.prototype.compare = function (key1, key2, extension, options) {
                    // Checks for support for Intl.
                    if (Intl_support_1.IntlSupport.Collator(this.languageCode) == false) {
                        return 0;
                    }
                    // Gets the value of translation for the keys.
                    var value1 = this.translate(key1);
                    var value2 = this.translate(key2);
                    ;
                    var locale = this.addExtension(this.languageCode, extension);
                    return new Intl.Collator(locale).compare(value1, value2);
                };
                /**
                 * Sorts an array of objects or an array of arrays by the current language code.
                 *
                 * @param list The array to be sorted
                 * @param keyName The column that contains the keys of the values to be ordered
                 * @param order 'asc' or 'desc'. The default value is 'asc'.
                 * @param extension
                 * @param options
                 * @return The same sorted list or the same list if Intl.Collator is not supported
                 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
                 */
                LocalizationService.prototype.sort = function (list, keyName, order, extension, options) {
                    if (list == null || keyName == null || Intl_support_1.IntlSupport.Collator(this.languageCode) == false)
                        return list;
                    // Gets the value of translation for the keys.
                    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                        var item = list_1[_i];
                        // Gets the value of translation for the key.
                        var value = this.translate(item[keyName]);
                        // Adds a new column for translated values.
                        var translated = keyName.concat("Translated");
                        // Updates the value in the list.
                        item[translated] = value;
                    }
                    var locale = this.addExtension(this.languageCode, extension);
                    // Intl.Collator.
                    var collator = new Intl.Collator(locale, options); // It can be passed directly to Array.prototype.sort.
                    list.sort(function (a, b) {
                        return collator.compare(a[translated], b[translated]);
                    });
                    // Removes the column of translated values.
                    var index = list.indexOf(translated, 0);
                    if (index > -1) {
                        list.splice(index, 1);
                    }
                    // Descending order.
                    if (order != null && order == 'desc') {
                        list.reverse();
                    }
                    return list;
                };
                /**
                 * Sorts an array of objects or an array of arrays by the current language code.
                 *
                 * @param list The array to be sorted
                 * @param keyName The column that contains the keys of the values to be ordered
                 * @param order 'asc' or 'desc'. The default value is 'asc'.
                 * @param extension
                 * @param options
                 * @return An observable of the sorted list or of the same list if Intl.Collator is not supported
                 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
                 */
                LocalizationService.prototype.sortAsync = function (list, keyName, order, extension, options) {
                    var _this = this;
                    return new Observable_1.Observable(function (observer) {
                        // Gets the sorted list.
                        observer.next(_this.sort(list, keyName, order, extension, options));
                        observer.complete();
                    });
                };
                /**
                 * Matches a string into an array of objects or an array of arrays.
                 *
                 * @param s The string to search
                 * @param list The array to look for
                 * @param keyNames An array that contains the columns to look for
                 * @param options
                 * @return A filtered list or the same list if Intl.Collator is not supported
                 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
                 */
                LocalizationService.prototype.search = function (s, list, keyNames, options) {
                    var _this = this;
                    if (options === void 0) { options = { usage: 'search' }; }
                    if (list == null || keyNames == null || s == "" || Intl_support_1.IntlSupport.Collator(this.languageCode) == false)
                        return list;
                    // Gets the value of translation for the each column.
                    var translated = new Array();
                    var i = 0;
                    for (var i = 0; i < keyNames.length; i++) {
                        // Adds a new column for translated values.
                        translated.push(keyNames[i].concat("Translated"));
                        for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
                            var item = list_2[_i];
                            // Gets the values of translation for the column.
                            var value = this.translate(item[keyNames[i]]);
                            // Updates the value in the list.
                            item[translated[i]] = value;
                        }
                    }
                    var locale = this.languageCode;
                    // Intl.Collator.
                    var collator = new Intl.Collator(locale, options);
                    var matches = list.filter(function (v) {
                        var found = false;
                        for (var i = 0; i < translated.length; i++) {
                            // Calls matching algorithm.
                            if (_this.match(v[translated[i]], s, collator)) {
                                found = true;
                                break;
                            }
                        }
                        return found;
                    });
                    // Removes the columns of translated values.
                    for (var i = 0; i < translated.length; i++) {
                        var index = matches.indexOf(translated[i], 0);
                        if (index > -1) {
                            matches.splice(index, 1);
                        }
                    }
                    return matches;
                };
                /**
                 * Matches a string into an array of objects or an array of arrays.
                 *
                 * @param s The string to search
                 * @param list The array to look for
                 * @param keyNames An array that contains the columns to look for
                 * @param options
                 * @return An observable for each element of the filtered list or the same list if Intl.Collator is not supported
                 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
                 */
                LocalizationService.prototype.searchAsync = function (s, list, keyNames, options) {
                    var _this = this;
                    if (options === void 0) { options = { usage: 'search' }; }
                    if (list == null)
                        return null;
                    if (keyNames == null || s == "" || Intl_support_1.IntlSupport.Collator(this.languageCode) == false)
                        return new Observable_1.Observable(function (observer) {
                            for (var _i = 0, list_3 = list; _i < list_3.length; _i++) {
                                var item = list_3[_i];
                                observer.next(item);
                            }
                            observer.complete();
                        });
                    return new Observable_1.Observable(function (observer) {
                        // Gets the value of translation for the each column.
                        var translated = new Array();
                        var i = 0;
                        for (var i = 0; i < keyNames.length; i++) {
                            // Adds a new column for translated values.
                            translated.push(keyNames[i].concat("Translated"));
                            for (var _i = 0, list_4 = list; _i < list_4.length; _i++) {
                                var item = list_4[_i];
                                // Gets the values of translation for the column.
                                var value = _this.translate(item[keyNames[i]]);
                                // Updates the value in the list.
                                item[translated[i]] = value;
                            }
                        }
                        var locale = _this.languageCode;
                        // Intl.Collator.
                        var collator = new Intl.Collator(locale, options);
                        for (var _a = 0, list_5 = list; _a < list_5.length; _a++) {
                            var v = list_5[_a];
                            for (var i = 0; i < translated.length; i++) {
                                // Calls matching algorithm.
                                if (_this.match(v[translated[i]], s, collator)) {
                                    observer.next(v);
                                    break;
                                }
                            }
                        }
                        // Removes the columns of translated values.
                        for (var i = 0; i < translated.length; i++) {
                            var index = list.indexOf(translated[i], 0);
                            if (index > -1) {
                                list.splice(index, 1);
                            }
                        }
                        ;
                        observer.complete();
                    });
                };
                LocalizationService.prototype.addExtension = function (locale, extension) {
                    // Adds extension.
                    if (extension != null && extension != "") {
                        locale = locale + "-" + extension;
                    }
                    return locale;
                };
                /**
                 * Matching algorithm.
                 *
                 * @param v The value
                 * @param s The string to search
                 * return True if match, otherwise false
                 */
                LocalizationService.prototype.match = function (v, s, collator) {
                    var vLength = v.length;
                    var sLength = s.length;
                    if (sLength > vLength)
                        return false; // The search string is longer than value.
                    if (sLength == vLength) {
                        return collator.compare(v, s) === 0;
                    }
                    // Tries to search the substring.
                    var found = false;
                    for (var i = 0; i < vLength - (sLength - 1); i++) {
                        var str = v.substr(i, sLength);
                        if (collator.compare(str, s) === 0) {
                            found = true;
                            break;
                        }
                    }
                    return found;
                };
                LocalizationService = __decorate([
                    core_1.Injectable(), 
                    __metadata('design:paramtypes', [http_1.Http, locale_service_1.LocaleService])
                ], LocalizationService);
                return LocalizationService;
            }());
            exports_1("LocalizationService", LocalizationService);
            /**
             * Defines the service state.
             */
            (function (ServiceState) {
                /**
                 * The translation data has been loaded.
                 */
                ServiceState[ServiceState["isReady"] = 0] = "isReady";
                /**
                 * The service is loading the data.
                 */
                ServiceState[ServiceState["isLoading"] = 1] = "isLoading";
                /**
                 * The service is waiting for the data.
                 */
                ServiceState[ServiceState["isWaiting"] = 2] = "isWaiting";
            })(ServiceState || (ServiceState = {}));
            exports_1("ServiceState", ServiceState);
            /**
             * Defines the loading mode.
             */
            (function (LoadingMode) {
                /**
                 * Initial state.
                 */
                LoadingMode[LoadingMode["Unknown"] = 0] = "Unknown";
                /**
                 * Direct loading.
                 */
                LoadingMode[LoadingMode["Direct"] = 1] = "Direct";
                /**
                 * Asynchronous loading.
                 */
                LoadingMode[LoadingMode["Async"] = 2] = "Async";
            })(LoadingMode || (LoadingMode = {}));
            exports_1("LoadingMode", LoadingMode);
        }
    }
});
